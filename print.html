<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ecam Eurobot</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="_FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="introduction.html">Introduction</a></li><li><a href="graphic/graphic_chart.html"><strong aria-hidden="true">1.</strong> Graphic chart</a></li><li><a href="mechanical/mechanical.html"><strong aria-hidden="true">2.</strong> Mechanical</a></li><li><ol class="section"><li><a href="mechanical/fusion.html"><strong aria-hidden="true">2.1.</strong> 3D modeling with Fusion360</a></li><li><a href="mechanical/3d-print.html"><strong aria-hidden="true">2.2.</strong> 3D printing</a></li><li><a href="mechanical/mecanum.html"><strong aria-hidden="true">2.3.</strong> Mecanum wheels</a></li><li><a href="mechanical/2018/lift.html"><strong aria-hidden="true">2.4.</strong> 2018 specifics</a></li><li><ol class="section"><li><a href="mechanical/2018/bigRobot.html"><strong aria-hidden="true">2.4.1.</strong> Block mechanism</a></li><li><a href="mechanical/2018/balls.html"><strong aria-hidden="true">2.4.2.</strong> Ball mechanism</a></li></ol></li></ol></li><li><a href="electronics/electronics.html"><strong aria-hidden="true">3.</strong> Electronics</a></li><li><ol class="section"><li><a href="electronics/actuators/actuators.html"><strong aria-hidden="true">3.1.</strong> Actuators</a></li><li><ol class="section"><li><a href="electronics/actuators/dynamixels.html"><strong aria-hidden="true">3.1.1.</strong> Dynamixels</a></li></ol></li><li><a href="electronics/sensors/sensors.html"><strong aria-hidden="true">3.2.</strong> Sensors</a></li><li><ol class="section"><li><a href="electronics/sensors/sonar.html"><strong aria-hidden="true">3.2.1.</strong> Sonar</a></li></ol></li><li><a href="electronics/pcb.html"><strong aria-hidden="true">3.3.</strong> PCB Design</a></li><li><a href="electronics/fpga.html"><strong aria-hidden="true">3.4.</strong> FPGA</a></li><li><a href="electronics/communication/communication.html"><strong aria-hidden="true">3.5.</strong> Communication</a></li><li><ol class="section"><li><a href="electronics/communication/i2c.html"><strong aria-hidden="true">3.5.1.</strong> I2C</a></li><li><a href="electronics/communication/spi.html"><strong aria-hidden="true">3.5.2.</strong> SPI</a></li><li><a href="electronics/communication/can.html"><strong aria-hidden="true">3.5.3.</strong> CAN</a></li></ol></li></ol></li><li><a href="software/software.html"><strong aria-hidden="true">4.</strong> Software</a></li><li><ol class="section"><li><a href="software/ros/ros.html"><strong aria-hidden="true">4.1.</strong> ROS</a></li><li><ol class="section"><li><a href="software/ros/install.html"><strong aria-hidden="true">4.1.1.</strong> Install</a></li><li><a href="software/ros/basics/basics.html"><strong aria-hidden="true">4.1.2.</strong> Basic concepts</a></li><li><ol class="section"><li><a href="software/ros/basics/workspace.html"><strong aria-hidden="true">4.1.2.1.</strong> Workspace setup</a></li><li><a href="software/ros/basics/packages.html"><strong aria-hidden="true">4.1.2.2.</strong> Packages</a></li><li><a href="software/ros/basics/pub.html"><strong aria-hidden="true">4.1.2.3.</strong> Publisher</a></li><li><a href="software/ros/basics/sub.html"><strong aria-hidden="true">4.1.2.4.</strong> Subscriber</a></li><li><a href="software/ros/basics/launch.html"><strong aria-hidden="true">4.1.2.5.</strong> Launchfiles</a></li><li><a href="software/ros/basics/params.html"><strong aria-hidden="true">4.1.2.6.</strong> ROS parameters</a></li></ol></li><li><a href="software/ros/advanced/advanced.html"><strong aria-hidden="true">4.1.3.</strong> Advanced concepts</a></li><li><ol class="section"><li><a href="software/ros/advanced/custom-msgs.html"><strong aria-hidden="true">4.1.3.1.</strong> Custom messages</a></li><li><a href="software/ros/advanced/model.html"><strong aria-hidden="true">4.1.3.2.</strong> Robot model</a></li><li><a href="software/ros/advanced/rviz.html"><strong aria-hidden="true">4.1.3.3.</strong> Rviz</a></li></ol></li><li><a href="software/ros/rosserial.html"><strong aria-hidden="true">4.1.4.</strong> ROS and Arduino</a></li><li><ol class="section"><li><a href="software/ros/arduino/publisher.html"><strong aria-hidden="true">4.1.4.1.</strong> Publisher</a></li><li><a href="software/ros/arduino/subscriber.html"><strong aria-hidden="true">4.1.4.2.</strong> Subscriber</a></li></ol></li><li><a href="software/ros/packages/packages.html"><strong aria-hidden="true">4.1.5.</strong> Useful packages</a></li><li><ol class="section"><li><a href="software/ros/packages/map.html"><strong aria-hidden="true">4.1.5.1.</strong> Map Server</a></li><li><a href="software/ros/packages/nav.html"><strong aria-hidden="true">4.1.5.2.</strong> Navigation stack</a></li></ol></li></ol></li><li><a href="software/image-processing.html"><strong aria-hidden="true">4.2.</strong> Image processing</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Ecam Eurobot</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#introduction" id="introduction"><h1>Introduction</h1></a>
<p>ROS or Robot Operating Systems is an open source framework designed for designing robots.
ROS is commonly installed upon a Linux operating system.
There are different ROS versions:</p>
<ul>
<li>Lunar (Latest)</li>
<li>Kinetic (LTS)</li>
<li>Jade</li>
<li>Indigo</li>
<li>...</li>
</ul>
<p>The ROS distribution we're using for Eurobot is the 'Kinetic' versions.</p>
<p>What's great about ROS, it's that there is an ever growing community that is sharing their code &amp; projects of robotic machines. This is great because there are many build-in/downloadable libraries ready to use and the end user doesn't need to reinvent the wheel for classic robotic manipulations, like for example:</p>
<ul>
<li>Drivers to read/write to sensors</li>
<li>Robotic algorithms (navigation, interpret sensor data, object manipulation)</li>
<li>...</li>
</ul>
<p>In this section we will go over the basic concepts of ROS, the actual installation and the realisation of a project from scratch.</p>
<a class="header" href="print.html#graphic-chart" id="graphic-chart"><h1>Graphic chart</h1></a>
<p><img src="graphic/graphic_chart.PNG" alt="alt text" /></p>
<a class="header" href="print.html#colors" id="colors"><h2>Colors</h2></a>
<p>The used colors in HEX format :</p>
<ul>
<li><strong>Blue</strong> :  012D5A</li>
<li><strong>Yellow</strong> : FFC72C</li>
</ul>
<a class="header" href="print.html#fonts" id="fonts"><h2>Fonts</h2></a>
<p>The fonts are available on https://dafont.com</p>
<ul>
<li><strong>ECAM</strong> : SF Distant Galaxy Italic</li>
<li><strong>Robotics</strong> : SF Distant Galaxy Outline Italic</li>
<li><strong>Brussels</strong> : Open Sans</li>
<li><strong>ENGINEERING SCHOOL</strong> : Open Sans Bold</li>
</ul>
<a class="header" href="print.html#files" id="files"><h2>Files</h2></a>
<p>The Adobde Illustrator files of the polo and the poster are available on the github.</p>
<a class="header" href="print.html#a1-getting-in-touch-with-fusion360" id="a1-getting-in-touch-with-fusion360"><h1>1. Getting in touch with Fusion360</h1></a>
<p>Fusion360 is a 3D modeling software used by many professionals and hobbyists to create pieces. You can directly send your models to slicers in order to print them or export the 2D plans to build it your own. The following few chapters should give you a global overview of how Fusion360 works and what you can use it for. We'll try to orient our writing to learn your to design in order to print your models later and will end with some tips about the printing of your designs.</p>
<p>To complete your learning we strongly recommend you subscribe to <a href="https://www.youtube.com/channel/UCo29kn3d9ziFUZGZ50VKvWA">Lars Christensen's Youtube channel</a>. He's a master in the use of Fusion360 and has very well made videos about every problem of question you might have.</p>
<p>3 videos in particular should hold your attention to get started:
<a href="https://www.youtube.com/watch?v=A5bc9c3S12g"> Fusion 360 Tutorial for Absolute Beginners— Part 1</a> and of course <a href="https://www.youtube.com/watch?v=HXRMzJWo0-Q"> Fusion 360 Tutorial for Absolute Beginners— Part 2</a>  and <a href="https://www.youtube.com/watch?v=zS8dYA_Iluc&t=614s"> Fusion 360 Tutorial for Absolute Beginners— Part 3</a>.</p>
<a class="header" href="print.html#fusion360-environment" id="fusion360-environment"><h2>Fusion360 environment</h2></a>
<p>The first window you get when opening Fusion360 for the first time should be this.</p>
<p>By clicking on <img src="img/mechanical/square.png" alt="img" /> you access to the repository holding all your folders.
A good practice is to sort them into other repositories according to their relevance.
<img src="img/mechanical/FOLDERS.png" alt="FOLDERS" /></p>
<a class="header" href="print.html#project-view" id="project-view"><h2>Project view</h2></a>
<p><img src="img/mechanical/Fusion1.png" alt="img" /></p>
<p>We'll let you listen to M.Christensen by clicking on the links of the videos we gave earlier to learn the basics of Fusion360. He's an expert on the subject and honestly the only good way to learn the kind of software is by watching someone do and copy. Please don't learn the shortcuts by heart, you'll learn the most used ones by practicing.</p>
<a class="header" href="print.html#a2-main-functions-and-shotcuts" id="a2-main-functions-and-shotcuts"><h1>2. Main Functions and Shotcuts</h1></a>
<p>You should already be able to do your first model now but in case of you misted some of the multiple things explained by &quot;Lars&quot;, we would like to give you a quick refresh.</p>
<p>To begin with, note that all function are easily available trough the &quot;s&quot; key shortcut. Just type some word related on what you are searching for and we are pretty sure that you'll find it fast. <em>Note that you can save them by clicking on the curved arrow.</em></p>
<a class="header" href="print.html#a21-shortcuts" id="a21-shortcuts"><h2>2.1. Shortcuts</h2></a>
<p>You don't have to study them but with your first hour of practice you should already know them. If it's still not the case, you'll find them here:</p>
<ul>
<li>S=Model Toolbox</li>
</ul>
<ul>
<li>L=Line</li>
<li>C=Circle</li>
<li>X=Construction</li>
<li>D=Dimension</li>
</ul>
<ul>
<li>Q=Push/Pull</li>
<li>M=Move</li>
<li>J=Joint</li>
<li>T=Trim (delete some lines)</li>
</ul>
<ul>
<li>center btn = Pan (move the view)</li>
<li>Maj+ center btn  = 3D move</li>
</ul>
<a class="header" href="print.html#a22-useful-functions" id="a22-useful-functions"><h2>2.2. Useful functions</h2></a>
<a class="header" href="print.html#offset" id="offset"><h3>Offset</h3></a>
<p>Offset is a very handy tool when it comes to draw parallel lines.
<img src="img/mechanical/Offset1.png" alt="img" /></p>
<p>The tools works only in sketch mode and you have to already have a reference line (or a shape). Type the &quot;o&quot;
key to open the &quot;offset menu&quot;, you then have to select the reference line you want. You can either drag and drop the cursor with your mouse or type the value you wish the offset to be.
<img src="img/mechanical/Offset_drag.png" alt="img" /><img src="img/mechanical/OFFSET_VALUE.png" alt="img" />
You'll end with the line/shape you selected offset as you wanted.
<img src="img/mechanical/Offset_finish.png" alt="img" /></p>
<a class="header" href="print.html#sweep" id="sweep"><h3>Sweep</h3></a>
<a class="header" href="print.html#revolve" id="revolve"><h3>Revolve</h3></a>
<p>Revolve allows you to create object as if you turned them on a lathe. It comes in handy to make wheels, cannons, ...
To used it you have to first create a shape around an axis. When you create that shape, you have to imagine it round. So you only have to draw &quot;a half cut in your future object&quot;.
<img src="img/mechanical/Vase_shape.png" alt="img" />
Type &quot;s&quot; to access the &quot;search menu&quot; and enter &quot;revolve&quot; to see the tool. You'll have to select the shape and the axis you want and press &quot;enter&quot;.
<img src="img/mechanical/vase_glass.png" alt="img" /></p>
<a class="header" href="print.html#appearance" id="appearance"><h3>Appearance</h3></a>
<p>To make design easier for others to imagine or simply to choose colors and material purely esthetically, the &quot;Appearance&quot; tool is a must! You can archive more or less the same result with the &quot;Physical Material&quot; tool, but this is more often used for simulation. You can also combine those tools to get for example a steel pipe covered in leather without having to create the wrapping in a component.
It is also very handy when creating complex assemblies with little pieces because the different appearance help to see those different pieces.</p>
<p>Appearance is really easy to use. Type &quot;a&quot;, choose the look you like and drag-drop it on the body you want. You can directly drop it in the project tree or on the visual objet.<br />
<img src="img/mechanical/Appearance_tool.png" alt="img" /></p>
<a class="header" href="print.html#pattern" id="pattern"><h3>Pattern</h3></a>
<p>Real time savior, &quot;Pattern&quot; allows you to duplicate sketches, bodies and components on a given distance.
Multiple pattern tools exists. To see then go into the &quot;search menu&quot; and type &quot;Pattern&quot;.
<img src="img/mechanical/multiple_patterns.png" alt="img" />
As you can see in the above picture, you can create a circular, rectangular or &quot;free style&quot; pattern.
For both rectangular and circular patterns the ones with white square create pattern in sketches. The grey ones create patterns of volumes (bodies, components). We'll only present the sketch pattern, but the volumes work in a similar way.</p>
<a class="header" href="print.html#rectangular-pattern" id="rectangular-pattern"><h4>Rectangular pattern</h4></a>
<p><img src="img/mechanical/Pattern_open.png" alt="img" />
To apply rectangular patterns, select the desired shape and the amount of copies you want in the 2 directions. You can then enter (or drag-drop) the distance on which you want to copy that shape for both directions and click &quot;ok&quot;.
<img src="img/mechanical/Rect_patt_1side.png" alt="img" />
<img src="img/mechanical/Rect_patt_2side.png" alt="img" />
<img src="img/mechanical/Rect_pattern_done.png" alt="img" /></p>
<a class="header" href="print.html#circular-pattern" id="circular-pattern"><h4>Circular pattern</h4></a>
<p>Circular patterns work in a similar way accept the fact you have to choose a center point and you can choose to make a complete revolution around it you on a given angle.
<img src="img/mechanical/circ_patt-full.png" alt="img" />
<img src="img/mechanical/circ_patt_angle.png" alt="img" /></p>
<a class="header" href="print.html#on-path" id="on-path"><h4>On path</h4></a>
<p>The 'On path pattern' tools allows you to create patterns that are nor circular, nor rectangular.
It only works with volumes and you have to enable the display of the sketch your path is in.</p>
<p><img src="img/mechanical/patt_onpath_start.png" alt="img" />
<img src="img/mechanical/Patt_ontpath_last.png" alt="img" />
<img src="img/mechanical/Patt_onpath_done.png" alt="img" /></p>
<a class="header" href="print.html#mirror" id="mirror"><h3>Mirror</h3></a>
<a class="header" href="print.html#fillet" id="fillet"><h3>Fillet</h3></a>
<p>As you used it in Autocad or similars, Fillet allow you to joint two lines to make one curve.
In Fusion 360, as a 3D software, you'll also find the possibility to &quot;curve&quot; your 3D model.
<img src="img/mechanical/Fillet_1.png" alt="img" /></p>
<figure>
  <figcaption>Fig. - First Fillet is for sketck and the second one for 3D model.</figcaption>
</figure>
<p>To use the sketch fillet, just select it and then click on the two lines to join.
<img src="img/mechanical/Fillet_2.png" alt="img" /></p>
<p>In the 3D model, just select the ridge and with the arrow or value chose the size of your fillet.
<img src="img/mechanical/Fillet_3.png" alt="img" />
<img src="img/mechanical/Fillet_4.png" alt="img" /></p>
<a class="header" href="print.html#chamfer" id="chamfer"><h3>Chamfer</h3></a>
<p>In the same way of thinking than for the Fillet, you'll have the possibility to make some Chamfer.
<img src="img/mechanical/Chamfer_1.png" alt="img" />
Select the tools and click on the ridge.
<img src="img/mechanical/Chamfer_2.png" alt="img" />
You'll also be able to do it with a curved ridge (the one made with fillet)
<img src="img/mechanical/Chamfer_3.png" alt="img" />
<img src="img/mechanical/Chamfer_4.png" alt="img" />
<em>Note that in this case you'll be limited by the angle of the previous made fillet.</em></p>
<a class="header" href="print.html#mecanum-wheels" id="mecanum-wheels"><h1>Mecanum wheels</h1></a>
<p><img src="img/mechanical/mecanum/mecanum.jpg" alt="" /></p>
<p>A mecanum wheel is a wheel with rollers attached at its circumference at an angle of typically 45°.
When four mecanum wheels are used together, we can achieve a net resulting direction in <strong>any</strong> direction by varying the direction and speed of rotation of the wheels.</p>
<a class="header" href="print.html#assembly" id="assembly"><h2>Assembly</h2></a>
<a class="header" href="print.html#wheel-adapter" id="wheel-adapter"><h3>Wheel adapter;</h3></a>
<p>To mount the wheels onto the motors, we need to use an adapter.
Due to an error in our order, we didn't receive the correct adapters and the ones we received didn't fit on the wheels.</p>
<p>We decided to 3D print our own as a replacement. The <a href="">STL file for this part can be found here</a>.</p>
<blockquote>
<p><strong>Note:</strong><br />
3D printing parts that will be under moderate or heavy mechanical stress is often not the best idea, because those parts will tend to break and/or wear out quickly.</p>
</blockquote>
<a class="header" href="print.html#wheel-orientation" id="wheel-orientation"><h3>Wheel orientation</h3></a>
<p>When assembling the wheels onto the robot, we need to pay attention to their orientation.
If we look from the top view, the rollers should all point to the center of the base.</p>
<p><img src="img/mechanical/mecanum/mecanum-orientation.png" alt="" /></p>
<a class="header" href="print.html#kinematics" id="kinematics"><h2>Kinematics</h2></a>
<p><strong>Forward kinematics</strong> refers to the use of the kinematic equations of a robot to compute the position of the end-effector from specified values for the joint parameters. In our case, the forward kinematics allow us to compute the global velocity of the robots base when given the angular velocities of the individual wheels.</p>
<p>The reverse process that computes the joint parameters that achieve a specified position of the end-effector is known as <strong>inverse kinematics</strong>. The inverse kinematic equations allow us, in our case, to compute the individual wheel velocities needed to achieve a given base velocity.</p>
<p>The equations presented in the next sections come from the following research paper: <a href="https://research.ijcaonline.org/volume113/number3/pxc3901586.pdf">&quot;Kinematic Model of a Four Mecanum Wheeled Mobile Robot&quot;</a></p>
<a class="header" href="print.html#inverse-kinematics" id="inverse-kinematics"><h3>Inverse kinematics</h3></a>
<p>The inverse kinematic equations allow us to compute the indiviual wheel velocities when we want to achieve an overall base velocity.</p>
<ul>
<li>\(\omega_{fl}\), \(\omega_{fr}\), \(\omega_{rl}\) and \(\omega_{rr}\)  represent the <em>angular velocities</em> for the front left, front right, rear left and rear right wheel respectively.</li>
<li>\(v_x\) and \(v_y\) represent the robot's base linear velocity in the x and y direction respectively. The x direction is in front of the robot.</li>
<li>\(\omega_z\) is angular velocity of the robot's base around the z-axis.</li>
<li>\(l_x\) and \(l_y\) represent the distance from the robot's center to the wheels projected on the x and y axis respectively.</li>
</ul>
<!-- MathJax math equation -->
\[
    \left\{\begin{matrix}
    \omega_{fl} &= \frac{1}{r} \left[v_x - v_y - (l_x + l_y)\omega_z \right ] \\ 
    \omega_{fr} &= \frac{1}{r} \left[v_x + v_y + (l_x + l_y)\omega_z \right ] \\ 
    \omega_{rl} &= \frac{1}{r} \left[v_x + v_y - (l_x + l_y)\omega_z \right ] \\ 
    \omega_{rr} &= \frac{1}{r} \left[v_x - v_y + (l_x + l_y)\omega_z \right ] 
    \end{matrix}\right.
\]
<p>Or in matrix form:</p>
<!-- MathJax math equation -->
\[
    \begin{bmatrix}
    \omega_{fl} \\ 
    \omega_{fr}\\ 
    \omega_{rl}\\ 
    \omega_{rr}
    \end{bmatrix}
    =
    \frac{1}{r}
    \begin{bmatrix}
    1 & -1 & -(l_x + l_y) \\ 
    1 &  1 &  (l_x + l_y) \\ 
    1 &  1 & -(l_x + l_y) \\ 
    1 & -1 &  (l_x + l_y)
    \end{bmatrix}
    \begin{bmatrix}
    v_x\\ 
    v_y\\ 
    \omega_z
    \end{bmatrix}
\]
<a class="header" href="print.html#example" id="example"><h4>Example</h4></a>
<p>If we want to let the robot move diagonally at <code>0.22 m/s</code> in the x direction and <code>0.11 m/s</code> in the y direction. At what speed should we set the motors of each wheel?</p>
<p>The robot is 15 cm in width and 20 cm in length. The wheels are placed at the extremities and have a diameter of 60 mm.</p>
<hr />
<!-- MathJax math equation -->
\[
    \left\{\begin{matrix}
    \omega_{fl} &= \frac{1}{0.03} \left[0.22 - 0.11 - (0.2 + 0.15) \cdot 0 \right ] = 3.66 \; rad / s\\ 
    \omega_{fr} &= \frac{1}{0.03} \left[0.22 + 0.11 + (0.2 + 0.15) \cdot 0 \right ] = 11 \; rad / s \\ 
    \omega_{rl} &= \frac{1}{0.03} \left[0.22 + 0.11 - (0.2 + 0.15) \cdot 0 \right ] = 11 \; rad/s \\ 
    \omega_{rr} &= \frac{1}{0.03} \left[0.22 - 0.11 + (0.2 + 0.15) \cdot 0 \right ] =  3.66 \; rad/s
    \end{matrix}\right.
\]
<hr />
<a class="header" href="print.html#forward-kinematics" id="forward-kinematics"><h3>Forward kinematics</h3></a>
<p>The forward kinematic equations allow us to compute the robot's base velocity when given the individual wheel velocities. This is usefull to compute the robot's odometry using the motor's embedded quadrature encoders.</p>
<p><em>Odometry is the use of sensor data to estimate the change in position of the robot over time.</em></p>
<!-- MathJax math equation -->
\[
    \left\{\begin{matrix}
    v_x & = (\omega_{fl} + \omega_{fr} + \omega_{rl} + \omega_{rr}) \cdot \frac{r}{4}\\ 
    v_y & = (-\omega_{fl} + \omega_{fr} + \omega_{rl} - \omega_{rr}) \cdot \frac{r}{4}\\ 
    \omega_z & = (-\omega_{fl} + \omega_{fr} - \omega_{rl} + \omega_{rr}) \cdot \frac{r}{4(l_x + l_y)}
    \end{matrix}\right.
\]
<p>Or in matrix form:</p>
<!-- MathJax math equation -->
\[
    \begin{bmatrix}
    v_x\\ 
    v_y\\ 
    \omega_z
    \end{bmatrix}
    =
    \frac{r}{4}
    \begin{bmatrix}
    1 & 1 & 1 & 1\\ 
    -1 & 1 & 1 & -1\\ 
    -\frac{1}{(l_x+l_y)} & \frac{1}{(l_x+l_y)} & -\frac{1}{(l_x+l_y)}  & \frac{1}{(l_x+l_y)} 
    \end{bmatrix}
    \begin{bmatrix}
    \omega_{fl}\\ 
    \omega_{fr}\\ 
    \omega_{rl}\\ 
    \omega_{rr}
    \end{bmatrix}
\]
<a class="header" href="print.html#the-big-robot-specifications" id="the-big-robot-specifications"><h1>The big robot specifications</h1></a>
<p><img src="mechanical/2018/bigrobot_render.PNG" alt="alt text" /></p>
<a class="header" href="print.html#fusion-360" id="fusion-360"><h2>Fusion 360</h2></a>
<p>The entire robot is designed in Fusion 360 and is available on the Eurobot cloud. The final version is called <strong>SHARK FINAL V17</strong></p>
<a class="header" href="print.html#parts" id="parts"><h2>Parts</h2></a>
<p>Most of the part are home made (CNC, 3D printing) but some parts a bought on the market :</p>
<ul>
<li>
<p><strong>IGUS rail</strong></p>
<ul>
<li><em>Small one</em>
<ul>
<li>Rail : Igus N Series, NS-01-17-300, Linear Guide Rail 17mm width 300mm length</li>
<li>Carriage : Igus Linear Guide Carriage NW-02-17, N</li>
</ul>
</li>
<li><em>Big one</em> :
<ul>
<li>Rail : Igus N Series, NS-01-27-300, Linear Guide Rail 27mm width 300mm length</li>
<li>Carriage : Igus Linear Guide Carriage NW-02-27, N</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Lift transmission</strong></p>
<ul>
<li><em>Pitch (distance between teeth)</em> : 2.032 mm</li>
<li><em>Pulley</em> : aluminium, Glass Filled PC Timing Belt Pulley, 6mm Belt Width x 2.032mm Pitch, 36 Tooth, Maximum Bore Dia. 5mm</li>
<li><em>Timing belt</em> : RS Pro, Timing Belt, 315 Tooth, 640.08mm Length X 6mm Width</li>
</ul>
</li>
<li>
<p><strong>Limit switch</strong></p>
<ul>
<li>Snap Action Limit Switch, Roller Lever, Thermoplastic, NC, 125V</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#ball-mechanism" id="ball-mechanism"><h1>Ball mechanism</h1></a>
<a class="header" href="print.html#introduction-1" id="introduction-1"><h1>Introduction</h1></a>
<p>Les dynamixels sont des servomoteurs ayant un angle de fonctionnement de 300° répartis sur des valeurs allant de 0 à 1023.</p>
<p><img src="electronics/actuators/Dynamixels_SRC/AngleFonctionnement.png" alt="alt text" /></p>
<p>Ils ont aussi la particularité de pouvoir être utilisés en tant que moteur DC. Ils ont un très bon couple moteur ce qui les rend efficaces pour un grand nombre d’applications. Dans nos robots, nous les avons utilisés pour leurs actions à réaliser pendant la compétition, à savoir :</p>
<ul>
<li>Trier des balles de différentes couleurs</li>
<li>Déployer un bras servant à pousser un objet roulant</li>
<li>Déployer une plateforme sur plusieurs étages afin de libérer des blocs cubiques</li>
<li>Retenir ou non les blocs de chaque étage</li>
<li>Actionner un engrenage servant à déplacer des blocs cubiques</li>
</ul>
<p>Le câblage se fait à l’aide de petits connecteurs 3pins.</p>
<p><img src="electronics/actuators/Dynamixels_SRC/PinsConnections.png" alt="alt text" /></p>
<p>Les dynamixels possèdent 2 emplacement pour ces connecteurs car il est possible de connecter plusieurs servomoteurs en série et de les contrôler avec un adressage. Ces adresses sont représentées par des ID uniques pour chaque dynamixel qu’il est possible de vérifier à l’aide du Dynamixel Wizard du logiciel Roboplus et d’une interface USB2Dynamixel.
Grâce à ce logiciel, il est également possible de configurer les dynamixels (registres) dont, entre autre, le baudrate du servomoteur ainsi que d’accéder à toute une série d’informations temps réel comme la vitesse, la position, etc.</p>
<a class="header" href="print.html#spécifications-techniques" id="spécifications-techniques"><h1>Spécifications techniques</h1></a>
<ul>
<li>Weight : 53.5g (AX-12/AX-12+), 54.6g (AX-12A)</li>
<li>Dimension : 32mm * 50mm * 40mm</li>
<li>Resolution : 0.29°</li>
<li>Gear Reduction Ratio :  254 : 1</li>
<li>Stall Torque : 1.5N.m (at 12.0V, 1.5A)</li>
<li>No load speed : 59rpm (at 12V)</li>
<li>Running Degree :  0° ~ 300° or Endless Turn</li>
<li>Running Temperature : -5℃ ~ +70℃</li>
<li>Voltage : 9  ~ 12V (Recommended Voltage 11.1V)</li>
<li>Command Signal : Digital Packet</li>
<li>Protocol Type : Half duplex Asynchronous Serial Communication (8bit,1stop,No Parity)</li>
<li>Link (Physical) : TTL Level Multi Drop (daisy chain type Connector)</li>
<li>ID : 254 ID (0~253)</li>
<li>Communication Speed : 7343bps ~ 1 Mbps</li>
<li>Feedback : Position, Temperature, Load, Input Voltage, etc.</li>
<li>Material : Engineering Plastic</li>
</ul>
<a class="header" href="print.html#dynamixel-wizard" id="dynamixel-wizard"><h1>Dynamixel Wizard</h1></a>
<ul>
<li>Télécharger le logiciel RoboPlus sur le site www.robotis.com en allant dans Support&gt;Download&gt;Software&gt;Roboplus</li>
</ul>
<p><img src="electronics/actuators/Dynamixels_SRC/DW_Roboplus.png" alt="alt text" /></p>
<ul>
<li>Lancer le logiciel et cliquer sur Dynamixel Wizard</li>
</ul>
<p><img src="electronics/actuators/Dynamixels_SRC/DW_DynamixelWizard.png" alt="alt text" /></p>
<ul>
<li>Insérer l’interface USB2Dynamixel dans un port USB de l’ordinateur</li>
<li>Brancher le connecteur 3 pins dans l’interface USB2Dynamixel (coté TTL) et dans le dynamixel à vérifier ou configurer</li>
<li>Sélectionner « TTL » à l’aide du switch sur l’interface USB2Dynamixel</li>
<li>Alimenter le dynamixel séparément dans sa plage de tension de fonctionnement (9-12V, recommandé 11,1V) à l’aide du 2eme port du dynamixel</li>
</ul>
<p><img src="electronics/actuators/Dynamixels_SRC/DW_USB2Dynamixel.png" alt="alt text" /></p>
<ul>
<li>Sélectionner le port de votre ordinateur auquel est branché l’USB2Dynamixel</li>
</ul>
<p><img src="electronics/actuators/Dynamixels_SRC/DW_Port.png" alt="alt text" /></p>
<ul>
<li>Cliquer ensuite sur « Ouvrir le port »</li>
</ul>
<p><img src="electronics/actuators/Dynamixels_SRC/DW_OuvrirLePort.png" alt="alt text" /></p>
<ul>
<li>Faire une recherche basique du dynamixel afin de trouver son ID</li>
</ul>
<ul>
<li>
<p>Il est également possible de faire des recherches plus avancées à d’autre baudrate dans le cas ou la recherche basique n’est pas concluante</p>
</li>
<li>
<p>Une fois le dynamixel trouvé, le sélectionner à gauche de la fenêtre.</p>
</li>
<li>
<p>Le détail des informations du dynamixel s’affiche</p>
</li>
<li>
<p>Dans ce détail, il est possible de modifier la configuration du dynamixel comme par exemple son ID, sa vitesse de communication (baudrate), sa vitesse de fonctionnement, etc, ou encore de le contrôler en temps réel.</p>
</li>
</ul>
<a class="header" href="print.html#exemples-dutilisation" id="exemples-dutilisation"><h1>Exemples d’utilisation</h1></a>
<p>Pour pouvoir utiliser les dynamixels, il est nécessaire au préalable de télécharger la librairie « AX_12A_servo_library » se trouvant sur github
Il faudra ensuite l’extraire et la déplacer dans Documents/Arduino/libraries.</p>
<p>Cette librairie possède 4 exemples d’utilisation du dynamixels :</p>
<ul>
<li>Blink : exemple de contrôle de la led rouge se trouvant à l’arrière du dynamixel</li>
<li>Move : exemple de contrôle du dynamixel en mode servomoteur en lui attribuant des positions</li>
<li>EndlessTurn : utilisation du dynamixel en mode moteur DC (ou wheel mode)</li>
<li>ReadRegister : sert à afficher le contenu des registres du dynamixel</li>
</ul>
<p>Ces exemples se trouvent dans Fichier&gt;Exemples&gt;AX-12A.</p>
<p>Après avoir sélectionner un des exemples, il faut inclure la librairie AX-12A sans déclarer un chemin spécifique car la librairie se trouve dans le dossier « libraries » du dossier « Arduino ».</p>
<p><img src="electronics/actuators/Dynamixels_SRC/Exemples_Include.png" alt="alt text" /></p>
<p>Ensuite il suffit de configurer 3 lignes dans le code qui répondront aux besoins et à la configuration du dynamixel branché :</p>
<p>#define DirectionPin  (10u)
#define BaudRate      (1000000ul)
#define ID            (1u)</p>
<p>DirectionPin sert à indiquer le sens de communication du dynamixel, 10u étant l’écriture dans les registres il n’est pas nécessaire de modifier sa valeur.</p>
<p>BaudRate définit la vitesse de communication utilisée (et configurée préalablement à l’aide du Dynamixel Wizard).</p>
<p>ID représente l’ID du dynamixel préalablement vérifiée ou configurée.</p>
<a class="header" href="print.html#références" id="références"><h1>Références</h1></a>
<ul>
<li>
<p>e-manual détaillé de l’ensemble des gammes de dynamixel le AX-12A qui nous interesse ici : http://support.robotis.com/en/</p>
</li>
<li>
<p>vidéo youtube reprenant différentes étapes de l’utilasation du Dynamixel Wizard : https://www.youtube.com/watch?v=YJ9b68hx5Qc&amp;version=3&amp;hl=ko_KR</p>
</li>
<li>
<p>site internet du fabricant : http://en.robotis.com</p>
</li>
<li>
<p>récupération de la librairie AX-12A : https://github.com/ThingType/AX-12A-servo-library</p>
</li>
</ul>
<a class="header" href="print.html#sonar" id="sonar"><h1>Sonar</h1></a>
<p>This is a draft of the tutorial, not the last version so all the instructions are not here yet.</p>
<p>This tutorial explains the code to use and transfer sonar sensors information with ROS.</p>
<p>For the «Cortex» robot we used four sensors, one on each side so that’s what the final code presented at the end of this tutorial is based on.</p>
<p>Firstly, in this code we are going to include the same libraries as shown in the Arduino Publisher Tutorial so you can refer to that part for the explanations.
An additional useful library used for the sensors is the NewPing.h. So here are all the necessary libraries :</p>
<pre><code>#include &lt;ros.h&gt;
#include &lt;sensor_msgs/Range.h&gt;
#include &lt;NewPing.h&gt;
</code></pre>
<p>Then you have to define the pins for each sensor. In this case, the ultrasound sensor has two pins (Trigger ans Echo). Here is an exemple with the sensor located on the right of the robot:</p>
<pre><code>#define TRIGGER_PINR  5
#define ECHO_PINR    4   
</code></pre>
<p>You also have to specify the maximum distance at which you want the sensor to still be able to detect :</p>
<pre><code>#define MAX_DISTANCE 300
</code></pre>
<p>Now as we are using the NewPing library you can simply create an ultrasound sensor object by doing this :</p>
<pre><code>NewPing sonarR(TRIGGER_PINR, ECHO_PINR, MAX_DISTANCE);
</code></pre>
<p>where you specify the pins and the maximum distance defined previously.</p>
<p>Moreover as mentioned in the Arduino Publisher Tutorial you specify the type of the ultrasound message and the name you want to assign to it :</p>
<pre><code>sensor_msgs::Range range_msg_right;
</code></pre>
<p>You also have to add the following line which has also been explained in the Arduino Publisher Tutorial :</p>
<pre><code>ros::Publisher pub_range4(&quot;ultrasound_right&quot;, &amp;range_msg_right);
</code></pre>
<p>We then have to fill each sonar object with the initialisation information associated :</p>
<pre><code>range_msg_right.radiation_type = sensor_msgs::Range::ULTRASOUND;
range_msg_right.header.frame_id =  &quot;ultrasound_right&quot;;
range_msg_right.field_of_view = 0.3665;  // fake
range_msg_right.min_range = 0.0;
range_msg_right.max_range = MAX_DISTANCE;
</code></pre>
<p>Now we can add parts to the void loop of the Arduino code. The most important and useful one specifies the distance to an obstacle :</p>
<pre><code>range_msg_right.range = tmp/100;
</code></pre>
<p>We can then publish that information about the distance (you can again refer to the Arduino Publisher Tutorial for the publishing part) :</p>
<pre><code>pub_range4.publish(&amp;range_msg_right);
</code></pre>
<p>Here is the whole code for four ultrasound sensors based on the one presented in this link :
<a href="https://www.youtube.com/watch?v=gm3e-51ohgQ">https://www.youtube.com/watch?v=gm3e-51ohgQ</a></p>
<pre><code>#include &lt;ros.h&gt;
#include &lt;sensor_msgs/Range.h&gt;
#include &lt;NewPing.h&gt;

#define TRIGGER_PINR  5   //back
#define ECHO_PINR    4   

#define TRIGGER_PINL  7   //front
#define ECHO_PINL     6  

#define TRIGGER_PINB  12   //left
#define ECHO_PINB     13 

#define TRIGGER_PINF  11   //right
#define ECHO_PINF     10 

#define MAX_DISTANCE 300 // Maximum distance we want to ping  

NewPing sonarL(TRIGGER_PINL, ECHO_PINL, MAX_DISTANCE); // back us 
NewPing sonarR(TRIGGER_PINR, ECHO_PINR, MAX_DISTANCE); // front us
NewPing sonarB(TRIGGER_PINB, ECHO_PINB, MAX_DISTANCE); // left us
NewPing sonarF(TRIGGER_PINF, ECHO_PINF, MAX_DISTANCE); // right us

ros::NodeHandle  nh;

sensor_msgs::Range range_msg_rear;
sensor_msgs::Range range_msg_front;
sensor_msgs::Range range_msg_left;
sensor_msgs::Range range_msg_right;
ros::Publisher pub_range1(&quot;ultrasound_rear&quot;, &amp;range_msg_rear);
ros::Publisher pub_range2(&quot;ultrasound_front&quot;, &amp;range_msg_front);
ros::Publisher pub_range3(&quot;ultrasound_left&quot;, &amp;range_msg_left);
ros::Publisher pub_range4(&quot;ultrasound_right&quot;, &amp;range_msg_right);
 

char frameid[] = &quot;base_link&quot;;

long duration;
 float tmp;

void setup()
{
  nh.initNode();
  nh.advertise(pub_range1);
  nh.advertise(pub_range2);
  nh.advertise(pub_range3);
  nh.advertise(pub_range4);

  range_msg_rear.radiation_type = sensor_msgs::Range::ULTRASOUND;
  range_msg_rear.header.frame_id =  &quot;ultrasound_rear&quot;;
  range_msg_rear.field_of_view = 0.3665;  // fake
  range_msg_rear.min_range = 0.0;
  range_msg_rear.max_range = MAX_DISTANCE;
  
  range_msg_front.radiation_type = sensor_msgs::Range::ULTRASOUND;
  range_msg_front.header.frame_id =  &quot;ultrasound_front&quot;;
  range_msg_front.field_of_view = 0.3665;  // fake
  range_msg_front.min_range = 0.0;
  range_msg_front.max_range = MAX_DISTANCE; 
   
  range_msg_left.radiation_type = sensor_msgs::Range::ULTRASOUND;
  range_msg_left.header.frame_id =  &quot;ultrasound_front&quot;;
  range_msg_left.field_of_view = 0.3665;  // fake
  range_msg_left.min_range = 0.0;
  range_msg_left.max_range = MAX_DISTANCE;  
  
  range_msg_right.radiation_type = sensor_msgs::Range::ULTRASOUND;
  range_msg_right.header.frame_id =  &quot;ultrasound_right&quot;;
  range_msg_right.field_of_view = 0.3665;  // fake
  range_msg_right.min_range = 0.0;
  range_msg_right.max_range = MAX_DISTANCE;
}

long range_time;

void loop()
{
  //publish the adc value every 50 milliseconds
  //since it takes that long for the sensor to stabilize
  if ( millis() &gt;= range_time ){
    tmp=sonarL.ping_cm();
    range_msg_rear.range = tmp/100;
    range_msg_rear.header.stamp = nh.now();
    pub_range1.publish(&amp;range_msg_rear);

    tmp=sonarR.ping_cm();
    range_msg_front.range = tmp/100;
    range_msg_front.header.stamp = nh.now();
    pub_range2.publish(&amp;range_msg_front);
    
     tmp=sonarB.ping_cm();
    range_msg_left.range = tmp/100;
    range_msg_left.header.stamp = nh.now();
    pub_range2.publish(&amp;range_msg_left);

    tmp=sonarF.ping_cm();
    range_msg_right.range = tmp/100;
    range_msg_right.header.stamp = nh.now();
    pub_range4.publish(&amp;range_msg_right);

    range_time =  millis() + 50;
  }
  nh.spinOnce();
}


</code></pre>
<p>#Printed Circuit Boards</p>
<p>Three types of printed circuit boards were developed for our two robots. The following section presents these boards, it utilities and it conception
and gives you all the necessary elements to understand, recreate and use it.</p>
<p>##Starting Board
Inspired by past version of the starting board</p>
<p>The utility of this PCB is to gather the component serving to the start sequence. Normally this is the only interface with the robot during the
competition.</p>
<p>First, we used three switches for configuring three mains points of our robot :</p>
<ul>
<li>
<p>Team configuration
We have to setup the starting side for the next match to the robot. It behaviour is different if the robot play as the green or the orange team.
Consequently, this switch set this point before the match start.</p>
</li>
<li>
<p>Strategy Configuration
It makes possible to choose between two kinds of implemented strategies before the match. For example, just before the start, we have the
possibility of aggressive or defensive strategy, function of the opponent.</p>
</li>
<li>
<p>Initialisation Switch</p>
</li>
</ul>
<p>This switch launches an initialisation sequence. After the power up of the robot and before its first move, we wanted to have the possibility to check
all different robot's systems. This switch indicates with a DEL if all systems are operational. This is a kind of automatic check list before the match
and the first move of the robot.</p>
<p>All these switches are linked to two DEL. First one to electrically confirm switches' position and the associated setting and the second one used to
have the response of the robot operating system. With these two DELs, we are sure that our robot understood all these parameters.</p>
<a class="header" href="print.html#useful-information" id="useful-information"><h3>Useful information</h3></a>
<ul>
<li>Correspondence</li>
</ul>
<p>Strategy</p>
<p>Pin 1 - UP   = GREEN = 0 (out raspberry) - DOWN  = RED = 1 (out raspberry)</p>
<p>Initialisation</p>
<p>Pin 2 - UP   = GREEN = 0 (out raspberry) - DOWN  = RED = 1 (out raspberry)</p>
<p>Team</p>
<p>Pin 3 - LEFT = GREEN = 1 (out raspberry) - RIGHT = RED = 1 (out raspberry)</p>
<p>Start</p>
<p>Pin 4 - piece IN     = 0 (out raspberry) - piece OUT   = 1 (out raspberry)</p>
<ul>
<li>Switch placement</li>
</ul>
<p>The emplacement is taken when the splayed side is on the right then :</p>
<ol>
<li>Strategy switch is in the upper left corner</li>
<li>Initialisation switch is on the right side of the strategy switch</li>
<li>Team switch is in the lower left corner</li>
</ol>
<p>Finally, the starter switch is plugged on the board. It consists of a relay, sending a binary information to the ROS operating system. Linked to a 0.5m
cable, this system allows to launch the match sequence pulling on it.</p>
<a class="header" href="print.html#motor-board" id="motor-board"><h2>Motor Board</h2></a>
<p>The goal of this board is to bring individual intelligence for every motor used on our robots. It allows to associate a microcontroller (ATmega328)
with each motor. This main component is used for two aspects : regulation and communication.</p>
<a class="header" href="print.html#regulation" id="regulation"><h3>Regulation</h3></a>
<p>For the smaller robot, the operating system send speed consign to the four motors. Consequently, the goal for the motor is reaching this speed in a
minimum of time and after conserving this value. The regulator implemented in the microcontrollers is Proportional Integral Derivative regulators.
It's parameters allow to influence the way to consign reaching for the motor. Thanks to it, each motor, individually can follow the ROS order with a
maximum of precision.</p>
<p>PID's parameters were found with experimentation and all sources used for implementation are in the code file.</p>
<a class="header" href="print.html#communication" id="communication"><h3>Communication</h3></a>
<p>As said in the previous part, this is the operating system ROS the main brain of the robot. Consequently, this brain has to communicate with its slave.
The communication protocol used on our robots is SPI. It induces that a bus has to be built between all motor and ROS. Effectively, a broker gathers
the signal for the motor but in any case each motor has to be linked to the bus. A role of the board is this connection via a SPI connector.</p>
<p>The commented code can be found in the root folder. For more information about the SPI communication, go to the SPI section.</p>
<a class="header" href="print.html#arduino-communication-shield---spi-broker" id="arduino-communication-shield---spi-broker"><h2>Arduino Communication Shield - SPI Broker</h2></a>
<p>Motor command communication consists of a two-level interface. ROS communicate via ROS Serial (explained in the appropriate section) implemented on an
arduino UNO and this arduino handle the communication with the four individual motors. To help for connections, we designed an arduino shield gathering
simply all SPI bus connections.</p>
<p>Again, you will find more explanation about the SPI communication in the right section and the basis of the ROS Serial use in the related section as
already said.</p>
<a class="header" href="print.html#annexe" id="annexe"><h2>Annexe</h2></a>
<p>All the boards adressed in this section are linked with the full Altium project in the root folder. It is the same for code and STL file for necessary 3D pieces.</p>
<a class="header" href="print.html#if-we-had-to-redo-it" id="if-we-had-to-redo-it"><h2>If we had to redo it</h2></a>
<p>If we had to design another robot with technologies described, there are some decision that we would change.</p>
<ul>
<li>PCB Design</li>
</ul>
<p>The ECAM installation for PCB printing is very useful for prototyping. It is not comparable with PCB that specialised company can create. So, our advice
is the following, as soon as a board is functional and definitive, send it to have a proper and reliable board. Moreover, try to reach this step as soon
as possible.</p>
<ul>
<li>Connection</li>
</ul>
<p>We have underestimated the connection on the different board. Regarding the JST connector, they are solid but hard to disconnect and cable creation is long withtout the right tool. About the 10 pins shrouded header, they are not reliable enough. Opposite to the JST, disconnection is too easy. We really advise against
its use. They were the source of a lot of problems.</p>
<a class="header" href="print.html#fpga" id="fpga"><h1>FPGA</h1></a>
<a class="header" href="print.html#a1-introduction" id="a1-introduction"><h2>1 INTRODUCTION</h2></a>
<p>The protocol that we will use is called Serial Peripheral Interface (SPI). It is a synchronous full-duplex serial interface and is commonly used to communicate with on-board peripherals such as EEPROM, FLASH memory, A/D converters, temperature sensors, or in our case a Field Programmable Gate Array (FPGA).
We assume a working knowledge of the VHDL hardware description language.</p>
<a class="header" href="print.html#a2-hardware" id="a2-hardware"><h2>2 HARDWARE</h2></a>
<p>SPI is a protocol, in which one device (the master) controls one or more other devices (the slaves). For the master we use an open-source microcontroller prototyping platform, such as the Arduino 101 or a modified Arduino UNO R3. In this document we use Arduino to refer to either platform.
The slave can be a low-cost FPGA prototyping platforms, such as the Xilinx Spartan-6 Avnet LX9 or the Altera Cyclone-IV Terasic DE10-Lite . The repository  includes project files and pin assignments for both these boards. The code is written in VHDL and should work equally well on more powerful boards.</p>
<a class="header" href="print.html#a21voltage-levels" id="a21voltage-levels"><h3>2.1.Voltage levels</h3></a>
<p>It is very important that the I/O voltage levels of the devices match. Both FPGA boards support 3.3V levels, and are a good match for the Arduino 101. However, the Arduino UNO uses the traditional 5 Volt TTL levels. Instead of using a level shifter, such as the 74LVC245, we opt for converting the Arduino to 3.3V according to Adafruit’s instructions. Running a 16 MHz clock at 3.3V is out of spec. Is said to work, but should really program the fuses to get the frequency down to abt. 13 MHz .</p>
<a class="header" href="print.html#a22signals" id="a22signals"><h3>2.2.Signals</h3></a>
<p>The SPI interface is a 4 wire interface. The bus consists of 3 signals plus <em>a slave select</em> signal for each device.</p>
<p><em>SCLK</em>: clock signal sent from the master to all slaves.</p>
<p><em>MOSI</em>: serial data from the master to the slaves (Master Out-Slave In).</p>
<p><em>MISO</em>: serial data from a slave to the master (Master In-Slave Out).</p>
<p><em>SS</em>:  slave select signal for each slave.</p>
<p>Once the Arduino runs at 3.3V, connecting the two devices becomes trivial.</p>
<a class="header" href="print.html#a221-pin-outs" id="a221-pin-outs"><h3>2.2.1. Pin outs</h3></a>
<p><img src="img/electronics/fpga/image1.png" alt="z" /></p>
<a class="header" href="print.html#a222-the-physical-connections" id="a222-the-physical-connections"><h3>2.2.2. The physical connections</h3></a>
<p><img src="img/electronics/fpga/image2.png" alt="z" /></p>
<a class="header" href="print.html#a3-byte--protocol" id="a3-byte--protocol"><h2>3. BYTE – PROTOCOL</h2></a>
<p>With the two devices physically connected, we need a protocol to transfer data. We chose the Serial Peripheral Interface (SPI), a lightweight protocol to connect one master to one or more slaves.</p>
<a class="header" href="print.html#a31-masterslave" id="a31-masterslave"><h3>3.1 Master/slave</h3></a>
<p>The SPI bus is controlled by a master device (typically a microcontroller) that orchestrates the bus access. The master generates the control signals and regulates the data flow. The illustration below shows a master with three slaves. The master uses the Slave Select (SS) signal to select the slave.</p>
<p><img src="img/electronics/fpga/image3.png" alt="z" /></p>
<a class="header" href="print.html#a32-parameters" id="a32-parameters"><h3>3.2 Parameters</h3></a>
<p>SPI is also a protocol with many degrees of freedom. It is important that the master and slave agree on the voltage levels and maximum clock frequency. The SPI clock polarity (CPOL) and clock phase (CPHA) introduce four more degrees of freedom as shown in the table below.
SPI parameters</p>
<p><img src="img/electronics/fpga/image4.png" alt="z" /></p>
<p>For this article we assume <em>mode 3</em>, where the clock is high when idle; data is driving following the falling edge of the clock and latched on the rising edge.</p>
<a class="header" href="print.html#a33-operation" id="a33-operation"><h3>3.3. Operation</h3></a>
<p>The protocol is easiest explained with shift registers as shown in the illustration below. The master generates the SPI Clock (<em>SCLK</em>) to initiate the information exchange. Data is shifted on one edge of this clock and is sampled on the opposite edge when the data is stable.</p>
<p><img src="img/electronics/fpga/image5.png" alt="z" /></p>
<p>In mode 3, at the falling edge of <em>SCLK</em>, both devices drive their most significant bit (<em>b7</em>) on their outgoing data line. On the rising edge, both devices clock in this bit into the least significant bit position (<em>b0</em>). After eight <em>SCLK</em> cycles, the master and slave have exchanged their values and each device processes the data received (e.g. writing it to memory). In case there is more data to be exchanged, the registers are loaded with new data and the process repeats itself. Once all data is transmitted, the master stops the <em>SCLK</em> clock.</p>
<a class="header" href="print.html#a34-slave-select" id="a34-slave-select"><h3>3.4. Slave select</h3></a>
<p>For a more complete picture, we need to include the effect of the <em>slave select</em> (<em>SS</em>*) signal that is used to address the slave devices.</p>
<p><img src="img/electronics/fpga/image6.png" alt="z" /></p>
<p>Slaves may only drive their output (<em>MISO</em>) line when <em>SS</em>* is active, otherwise they should tri-stated the output. The protocol can be broken down into the following steps:</p>
<ol>
<li>
<p>The master initiates the communication by activating SS*</p>
</li>
</ol>
<ul>
<li>The slave responds by starting to drive its MISO output.</li>
</ul>
<ul>
<li>
<p>Meanwhile the master drives its MOSI output.</p>
</li>
</ul>
<ol start="2">
<li>
<p>The master makes SCLK low.</p>
</li>
</ol>
<ul>
<li>
<p>On this falling edge, the master and slave drive their most significant bit position (b7) on respectively their MOSI and MISO outputs.</p>
</li>
</ul>
<ol start="3">
<li>
<p>The master makes SCLK high.</p>
</li>
</ol>
<ul>
<li>
<p>On this rising edge, the master and slave clock the input from their respectively MISO and MOSI inputs into the least significant bit position (b0).</p>
</li>
</ul>
<ol start="4">
<li>
<p>Go back to step 2. Until the least significant bit position (b0) has been sent.</p>
</li>
<li>
<p>When all bits are transmitted, the master deactivates SS*.</p>
</li>
</ol>
<a class="header" href="print.html#a4-bytes-exchange-with-arduino-as-master" id="a4-bytes-exchange-with-arduino-as-master"><h2>4. BYTES EXCHANGE WITH ARDUINO AS MASTER</h2></a>
<p>The Arduino is blessed with a support library for the serial peripheral interface. This greatly aids the implementation. For the slave we used an Altera or Xilinx based FPGA implementation . Refer to the first part of this article for details about the physical connection.</p>
<a class="header" href="print.html#a5-byte-exchange-with-a-fpga-as-slave" id="a5-byte-exchange-with-a-fpga-as-slave"><h2>5. BYTE EXCHANGE WITH A FPGA AS SLAVE</h2></a>
<p>Implementing the SPI Slave on an FPGA is like old school digital electronics. My key takeaway is to think hardware, not programming. Implementing the <a href="https://coertvonk.com/hw/logic/connecting-fpga-and-arduino-using-spi-13067/3">SPI protocol</a> on a FPGA is fairly straightforward for as long as we use a directly clocked sequential circuit while preventing clock domain crossings.</p>
<a class="header" href="print.html#a51-sequential-circuit" id="a51-sequential-circuit"><h3>5.1. Sequential circuit</h3></a>
<p>In real life, two signals going to a single gate will not arrive there at the same time due to wire delays. This causes the output to momentarily have an incorrect value. The problem compounds as the signal travels through more gates and wires.</p>
<p>In Building Math Hardware we created elementary math operations using combinatorial circuits. That was OK, because we didn’t care about such output <em>glitches</em> caused by the input signals propagating to the outputs. From a demonstrator’s point of view it even made it more interesting. Talking to a real device, such as a SPI master is different, because it requires the outputs to be stable at certain times.</p>
<p><img src="img/electronics/fpga/image7.png" alt="z" /></p>
<p>The solution is to introduce a clock signal, and store the signals in a flip-flop (registers) at the rising edge of that clock signal. We then only need to ensure that the longest delay from one flip-flop to the next is less that the clock period. This greatly simplifies the design process, at the cost of introducing some delay.</p>
<a class="header" href="print.html#a52-clock-domain" id="a52-clock-domain"><h3>5.2. Clock domain</h3></a>
<p>Field programmable gate arrays thrive on synchronous designs, but they don’t do well with clock signals that are asynchronous with its system clock.</p>
<p>We also need to avoid transferring data from a <a href="https://coertvonk.com/family/school/inquiries/computer-math-inquiry-4245">flip-flop</a> driven by one clock to a flip-flop driven by another clock. This is called a <em>clock domain crossing</em> and might manifest itself in <em>metastability</em>, data loss or incoherence .We prevent clock domain crossings, by synchronizing the input signals to the FPGA clock using a traditional two-stage shift register as illustrated above.</p>
<ul>
<li>
<p>The first flip-flop creates a synchronous version of the inputs by clocking it with the system clock. The input signal could change within the flip-flop’s <em>setup and hold times</em> and may take longer than a system clock cycle to settle to a stable value (metastability). That’s why it is ran through a second flip-flop.</p>
</li>
<li>
<p>The second flip-flop, makes it is very unlikely that this metastability propagates to the output.</p>
</li>
<li>
<p>Adding a third flip-flop gives us access to the previous value. Using the current and previous values, we can generate rise and fall signals as sown below.</p>
<p><img src="img/electronics/fpga/image8.png" alt="z" /></p>
</li>
</ul>
<a class="header" href="print.html#a53-operation" id="a53-operation"><h3>5.3. Operation</h3></a>
<p>The main data object is an 8-bit register called DATA.</p>
<p>On a falling SCLK edge, the most significant bit from data is clocked into a register from where it is transmitted over its MISO output.</p>
<p>On a rising SCLK edge, the MOSI input is shifted into the least significant bit of data.</p>
<p>Once all eight bits are received, the byte is available as rx. This received byte rx should be read when rx Valid is active during a rising edge of the sysClk.</p>
<a class="header" href="print.html#a6-message-exchange-protocol" id="a6-message-exchange-protocol"><h2>6. MESSAGE EXCHANGE PROTOCOL</h2></a>
<p>The time has come to implement a status and register interface on top of the raw byte exchange. We define a few commands to retrieve the device status and access its 32-bit registers.</p>
<a class="header" href="print.html#a61-commands" id="a61-commands"><h3>6.1. Commands</h3></a>
<p>The first byte is defined as the command byte. The interpretation of the remaining bytes (if any) depends on this command. After the command is completed, a new command can be sent. The following commands will be supported:</p>
<ul>
<li><strong>Read status (0x00)</strong>: Reads the status byte.</li>
</ul>
<p>First the master sends 0x00, and ignores the value returned;</p>
<p>the master then sends one dummy byte, to get the 8-bit status value in return.</p>
<ul>
<li><strong>Read register (0x80 to 0x8F)</strong>: Reads the value stored in one of the sixteen registers.</li>
</ul>
<p>The least significant four bits of the command indicate the register to read from.
First the master sends this command, and ignores the value returned,then the master sends 4 dummy bytes to get the 32-bit register value. The first byte received is the most significant, the fourth is the least significant (network byte order).</p>
<ul>
<li>
<p><strong>Write register (0xC0 to 0xCF)</strong>: Writes a value to one of the sixteen registers. The least significant four bits indicate the register to write to.</p>
<ul>
<li>First the master sends the command, and ignores the value returned;</li>
<li>Then the master sends 4 bytes with the value to write. The most significant byte is sent first, the least significant last.</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#a62-registers" id="a62-registers"><h3>6.2. Registers</h3></a>
<p>The FPGA will implement two register types. The first 4 registers (0-3) are <em>read/write</em> and can be used to send information to the FPGA. The next 12 registers (4-15) are <em>read-only</em> to receive information from the FPGA. In the greater scheme, the <em>read/write</em> registers will be used to send math operands to the FPGA, and the read-only registers will be used to read the results from the FPGA.</p>
<a class="header" href="print.html#a63-room-for-improvement" id="a63-room-for-improvement"><h3>6.3. Room for improvement</h3></a>
<p>The protocol leaves some room for improvement. It can be made more efficient by implementing continuous commands. Here the master issues a <em>read</em> or <em>write register start</em> command, but keeps sending sets of 4-bytes until it has enough. Along similar lines one could implement commands to access attached memory.</p>
<a class="header" href="print.html#a7-messages-exchange-with-arduino-as-master" id="a7-messages-exchange-with-arduino-as-master"><h2>7. MESSAGES EXCHANGE WITH ARDUINO AS MASTER</h2></a>
<p>Again, we’ll use the support library for the serial peripheral interface. The code shown below was tested on a 3.3 Volt Arduino UNO R3 connected to FPGA implementation.</p>
<p>#Serial Peripheral Interface (SPI)</p>
<blockquote>
<p><em>last updated on April 22, 2018</em></p>
</blockquote>
<p>##Quick theoretical reminders</p>
<p>The Serial Peripheral Interface bus (SPI) is a synchronous serial communication interface specification used for short distance communication, primarily in embedded systems.</p>
<p>You can see on the picture below the topology of this communictaion interface and the pinout of the components:</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/fc/SPI_three_slaves.svg/363px-SPI_three_slaves.svg.png" alt="" /></p>
<p>To begin a communication with a <em>Slave</em>, the <em>Master</em> must fix the Slave Select pin (SS) to <strong>LOW</strong> state. After that, the master can put somme bit into the shift register throught the MOSI  (Master Output Slave Input) pin. There isn't any standard communiction protocol but the communiction frame is often writen for the use. When the communication is done, it's the master who must put back the SS to <strong>HIGH</strong> State.</p>
<blockquote>
<p><strong>Note</strong> :
It's a full duplex interface, The slave can push some data on his MISO (Master Input Slave Output) pin during the communication.</p>
</blockquote>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/bb/SPI_8-bit_circular_transfer.svg/500px-SPI_8-bit_circular_transfer.svg.png" alt="" /></p>
<p>###advantages</p>
<ul>
<li>Full duplex communication</li>
<li>Flexibility of the number of bits to be transmitted as well as the protocol itself</li>
<li>no possible collision</li>
</ul>
<p>###disadvantage</p>
<ul>
<li>(3 + N*Slaves) pins are required on the master</li>
<li>4 pins are required on each slaves</li>
<li>Master can speak in a vacuum without knowing it</li>
<li>Bus can only count one master</li>
</ul>
<p>##Use of our SPI</p>
<p>the communication frame we used to send data to the slave is:</p>
<ol>
<li>Register adress on 8 bits</li>
<li>Number of bytes composing the message</li>
<li>Message</li>
</ol>
<blockquote>
<p><strong>Note</strong> :
to read some data from a slave's register, the master must just send the register adress. The slave push the data on his MISO (Master Input Slave Output) pin.</p>
</blockquote>
<p>###Our Master
Create a SPI Master is really easy with a atmega328p and the arduino IDE. Indeed, we can find easily some libraries. We used the one provided directly by the arduino IDE in an object that we implemented : <a href="https://github.com/Ecam-Eurobot/Eurobot-2018/blob/master/arduino/SPIManager.cpp">SPIManager</a></p>
<p>how to work with <a href="https://github.com/Ecam-Eurobot/Eurobot-2018/blob/master/arduino/SPIManager.cpp">SPIManager</a> object will be illustrated at least code use for Cortex's engines control (Eurobot 2018) : <a href="https://github.com/Ecam-Eurobot/Eurobot-2018/blob/master/arduino/Ecam/examples/MotorControl/MotorBroker/MotorBroker.ino">MotorBroker</a></p>
<p>#####1. Initialisation of the SPI communication
The <a href="https://github.com/Ecam-Eurobot/Eurobot-2018/blob/master/arduino/SPIManager.cpp">SPIManager</a> object must be seen as a communication channel with the slave. It will be necessary to instantiate one <a href="https://github.com/Ecam-Eurobot/Eurobot-2018/blob/master/arduino/SPIManager.cpp">SPIManager</a> object by slave. When creating the object, use the number of the SS pin as an argument.</p>
<pre><code class="language-c">//Define the SS pin for each slave
#define FL_SS  9
#define FR_SS  2
#define BL_SS  10
#define BR_SS  3

//Object Instantiation
SPIManager connFL(FL_SS);
SPIManager connFR(FR_SS);
SPIManager connBL(BL_SS);
SPIManager connBR(BR_SS);
</code></pre>
<p>Use the <em>initialize()</em> method to activate the communication channel. This call should be placed in the <em>setup()</em> function of the arduino code.</p>
<pre><code class="language-c">connFL.initialize();
</code></pre>
<p>#####2. Write data to a Slave's register
as said above, to write a value in a register of the slave will first send the address of the register, then the size in number of byte and to finish, the message.</p>
<p>The <em>writedata</em> function has been written to make its use as intuitive as possible.
below, an example of use where we send to the register <strong>16</strong> (0x10), the message <strong>x.b</strong> whose size is <strong>4 bytes</strong>.</p>
<pre><code class="language-c">connBR.writeData(0x10, 0x04, x.b);
</code></pre>
<p>#####3. Read data from a Slave's register
There are two functions to read some data: the first,<em>readLongData</em> , will return a value of type <strong>long</strong> and the other ,<em>readData</em> , a value of type <strong>float32</strong></p>
<p>below, an example of use where we get some data from th register <strong>81</strong> (0x51).</p>
<pre><code class="language-c">encoders_msg.rear_left = connBL.readLongData(0x51);
</code></pre>
<blockquote>
<p>from here the documentation is still being written</p>
</blockquote>
<p>###Our Slaves
When using the Arduino IDE to program atmeg328p, the slave mode is not available. Two registers must be modified to <em>activate</em> this mode :</p>
<pre><code class="language-c">// turn on SPI in slave mode
SPCR |= _BV(SPE);
// turn on interrupts
SPCR |= _BV(SPIE);
</code></pre>
<p>So that these manipulations are transparent for the user we also create an object for the SPI bus slaves : <a href="https://github.com/Ecam-Eurobot/Eurobot-2018/blob/master/arduino/SPIslave.cpp">SPISlave</a></p>
<p>this object has several methods :</p>
<ol>
<li>begin()</li>
<li>reset()</li>
<li>com()</li>
</ol>
<p>and some properties :</p>
<ol>
<li>command</li>
<li>dataSize</li>
<li>msg</li>
<li>endtrans</li>
</ol>
<p>#####1. Initialisation of the SPI communication</p>
<pre><code class="language-c">SpiSlave mySPI;
//SLK  : pin 13
//MISO : pin 12
//MOSI : pin 11 
#define SS 10
</code></pre>
<pre><code class="language-c">mySPI.begin();
</code></pre>
<p>#####2. Interruption</p>
<pre><code class="language-c">//Interrupt needed by SPI Communication
ISR (SPI_STC_vect) {
    mySPI.com(SPDR); 
    spiReg();//Function called at the end of the communication.   
}
</code></pre>
<p>#####3. Registers</p>
<pre><code class="language-c">void spiReg(){  
switch (mySPI.command) {
  case 0x10:
      if(mySPI.endTrans) {
          for (int i = 0; i &lt; 4; i++){
              motor_speed.b[i] = mySPI.msg[i];
           }
       }
      break;
   case 0x11:
      SPDR = motor_speed.b[mySPI.dataCount - 2];
      break;
   case 0x50:
      motor_encoder.write(0);
      break;    
   case 0x51:
      SPDR = EncoderState.b[mySPI.dataCount - 2];
      break;    
  } 
}
</code></pre>
<p>###Troubleshooting</p>
<p>#####1. Problem between serial port (ROSSERIAL) and SPI bus
#####2. sometimes the slave update the value of a register with the value received previously
#####3. Changing the values of a register when reading another register</p>
<a class="header" href="print.html#references" id="references"><h1>References</h1></a>
<p><a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus">https://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus</a></p>
<a class="header" href="print.html#why-using-canbus-on-the-robots-and-how-to-implement-it" id="why-using-canbus-on-the-robots-and-how-to-implement-it"><h1>Why using CANBus on the robots and how to implement it</h1></a>
<a class="header" href="print.html#issues-and-context-of-the-eurobot--2018-" id="issues-and-context-of-the-eurobot--2018-"><h2>Issues and context of the Eurobot ( 2018 )</h2></a>
<p>Many technologies have been implemented on the robots for the 2018 edition of the EUROBOT.</p>
<p>Those technologies were a huge step forward in terms of quality, speed and ease of use.</p>
<p>However, unexpected downsides appeared during the implementation of the technologies on the robots.</p>
<p>Thoses downsides are of all type but those who are speaking about during this tutorial are *<em>electronic</em> and <strong>space</strong>.</p>
<p><img src="electronics/communication/CAN_SRC/complex-wiring.png" alt="alt text" title="Logo Title Text 1" /></p>
<a class="header" href="print.html#electronic-problem" id="electronic-problem"><h3>Electronic problem</h3></a>
<p>Once the boards are installend on the robots, they needed a lot of connections between them. The last picture shows the kind of result we got after connecting all the wires.</p>
<p>From that moment it is very complex to add or remove wires because of the big amount of cables.</p>
<p>It is also very complex for the debugging because it is hard to take measures and to find where the error is.</p>
<a class="header" href="print.html#space-problem" id="space-problem"><h3>Space problem</h3></a>
<p>Another problem wich appeared and that we didn't is the huge space taken by the wires.</p>
<p>During the conception the <strong>mistake</strong> we did is to disregard the size of the wires. In the future, some leeway should be taken on the size of the robot during the conception.</p>
<p>The huge number of wires had also an mechanical impact. It added constraint on the connexions wich often broke.</p>
<a class="header" href="print.html#le-canbus" id="le-canbus"><h2>Le CANBus</h2></a>
<a class="header" href="print.html#context" id="context"><h3>Context</h3></a>
<p>Those problems have already been met many years ago in the automotive. Indeed, more and more electronic devises were used in the cars for differents purposes :</p>
<ul>
<li>Engine temperature, air...</li>
<li>RPM, speed...</li>
<li>accelerometer...</li>
<li>Safety, ABS, Airbag, opened doors, seatbelt...</li>
</ul>
<a class="header" href="print.html#specifications" id="specifications"><h3>Specifications</h3></a>
<p>We can cleary see that with the number of wires increasing the wiring harness became a real problem.</p>
<p>To resolve this, BOSCH developped the CANBus with several caracteristics :</p>
<ul>
<li>High speed communication up to 1 Megabit/s (see the table below for more information)</li>
<li>Real time ( wich makes CANBus better than TCP/IP)</li>
<li>Error detection, fast recovery and repair ( stil in real time)</li>
<li>Security and stability</li>
<li>Priorization of transmission</li>
<li>Based on a differiental signal, the CANBus is made for harsh environnements (External noises and fault tolerance)</li>
<li>It uses a twisted pair cable wich limits the noise emition</li>
</ul>
<p>You can see below the speed transmission according to the distances</p>
<p><img src="electronics/communication/CAN_SRC/can_speed.PNG" alt="alt text" /></p>
<a class="header" href="print.html#topology" id="topology"><h4>Topology</h4></a>
<p>Finally, the biggest benefit of the CANBus is his one bus line topology which limits the number of cables to 4. (CAN HIGH, CAN LOW, VCC and GROUND).</p>
<p>This the reason why it is used on every modern car.</p>
<p><img src="electronics/communication/CAN_SRC/can_topology.png" alt="alt text" /></p>
<p>We can see on the last figure a system without the CANBus (left) and a system with the CANBus (right).</p>
<p>Every component, called a node, is connected to the bus line like the figure below :</p>
<p><img src="electronics/communication/CAN_SRC/can_busnode.jpg" alt="alt text" /></p>
<p>By analogy, the CANBus can be represented by a number of people ( the nodes ) in a room ( the bus line ) where everybody screams his informations. Everyelse has the choice to listen or not. A priority system chooses who is going to speak when several people want to speak at the same time.</p>
<a class="header" href="print.html#the-frame" id="the-frame"><h3>The frame</h3></a>
<p><img src="electronics/communication/CAN_SRC/can_frame.jpg" alt="alt text" /></p>
<p>A data frame is made of different parts :</p>
<ul>
<li>1 dominant bit begins the frame</li>
<li>The ID of the message is made of 11 bits in the standart CAN or 29 bits in the extended CAN.</li>
<li>6 bits which determine the lenght of the frame</li>
<li>The data made of 0...8 bytes</li>
<li>15 bits of CRC to detect errors</li>
<li>ACK</li>
<li>End of frame bit</li>
</ul>
<a class="header" href="print.html#priority-of-transmission" id="priority-of-transmission"><h3>Priority of transmission</h3></a>
<p>When differents nodes whant to talk at the same time on the bus line, it is the ID who is going to determine the priority.</p>
<p>It gives an important advantage to CANBus, it is possible to make priority of transmission by choosing the right ID. For example, in car the brake system is more important than the light system. The ID of the brake system will be lower ( more 0 ) than the light system.</p>
<a class="header" href="print.html#implementation" id="implementation"><h2>Implementation</h2></a>
<a class="header" href="print.html#hardware" id="hardware"><h3>Hardware</h3></a>
<p><img src="electronics/communication/CAN_SRC/can_hardware.png" alt="alt text" /></p>
<p>The last figure shows the implementation of the CANBus. The implementation is quite easy because of the modules proposed by Microchip.</p>
<p>A node is made of a transceiver, a CAN controller and a microcontroller.</p>
<a class="header" href="print.html#transceiver" id="transceiver"><h4>Transceiver</h4></a>
<p>Microchip proposes a lot of solutions for the automotive including a transceiver.</p>
<p>It is the MCP2562. Formerly the MCP2551, is used to convert the TTL signal to a differential signal required by the CANBus.</p>
<a class="header" href="print.html#controller" id="controller"><h4>Controller</h4></a>
<p>Microchip also proposes the CAN controller MCP2515 which implements all the CAN 2.0 specifications. It is able to send and receive data and communicate it via SPI to a microcontroller.</p>
<a class="header" href="print.html#microcontroller" id="microcontroller"><h4>Microcontroller.</h4></a>
<p>Any microcontroller with an integrated SPI communication can be selected.</p>
<p>For example we can take the famous ATMEGA328p known for his arduino IDE.</p>
<a class="header" href="print.html#resistance" id="resistance"><h4>Resistance</h4></a>
<p>In every communication wire there is some reflexion that can corrupt the data. It can be avoided by using 120 Ohm resistor at the end of line.</p>
<a class="header" href="print.html#pcb" id="pcb"><h4>PCB</h4></a>
<p>Coming soon.</p>
<a class="header" href="print.html#software-arduino" id="software-arduino"><h3>Software (Arduino)</h3></a>
<p>There are many libraries that propose functions to interract with the CAN controller via SPI from the micrcontroller.</p>
<p>A very comlete and up to date library is the Seed studio lib :
<a href="https://github.com/Seeed-Studio/CAN_BUS_Shield">https://github.com/Seeed-Studio/CAN_BUS_Shield</a></p>
<a class="header" href="print.html#filters" id="filters"><h4>Filters</h4></a>
<p>Filters allow to choose wich messages will be sent to the microcontroller from the CAN controller.</p>
<p>The MCP2515 is able the define 6 filters. For example :</p>
<pre><code class="language-javascript">CAN.init_Filt(0, 0, 0x04);                          
CAN.init_Filt(1, 0, 0x05);                          
</code></pre>
<p>This code means that the CAN controller will only listen to the messages with an ID of 0x04 and 0x05.</p>
<a class="header" href="print.html#masks" id="masks"><h4>Masks</h4></a>
<p>The masks defines the bits that will be inspected to filter the coming ID. If the bit of the mask is 1, it means that the ID has to respect the bit of the filter.</p>
<p>For example with the following filter :</p>
<pre><code class="language-javascript">0100 1101
</code></pre>
<p>If the mask is :</p>
<pre><code class="language-javascript">1111 1111
</code></pre>
<p>Then it means that the accepted ID has to have exactly the same bits thant the filter because all the masks bits are 1. Only a message witch the next ID will be accepted :</p>
<pre><code class="language-javascript">0100 1101
</code></pre>
<p>Now, if the mask is this one :</p>
<pre><code class="language-javascript">1111 1110
</code></pre>
<p>It means that the filter will not inspect the last bit of the ID.</p>
<p>The next ID's will be accpeted</p>
<pre><code class="language-javascript">0100 1100
0100 1101
</code></pre>
<a class="header" href="print.html#usefull-links" id="usefull-links"><h1>Usefull links</h1></a>
<ul>
<li>Introduction to CANBus by Texas Instrument, <a href="http://www.ti.com/lit/an/sloa101b/sloa101b.pdf">http://www.ti.com/lit/an/sloa101b/sloa101b.pdf</a></li>
<li>CAN specs by BOSCH, <a href="https://www.kvaser.com/software/7330130980914/V1/can2spec.pdf">https://www.kvaser.com/software/7330130980914/V1/can2spec.pdf</a></li>
<li>CANBus implementation with Arduino, <a href="http://www.prometec.net/wp-content/uploads/2015/07/Controller-Area-Network-Prototyping-With-Arduino-Wilfried-Voss.pdf">http://www.prometec.net/wp-content/uploads/2015/07/Controller-Area-Network-Prototyping-With-Arduino-Wilfried-Voss.pdf</a></li>
<li>Well documented on Wikipedia, https://en.wikipedia.org/wiki/CAN_bus</li>
</ul>
<a class="header" href="print.html#ros" id="ros"><h1>ROS</h1></a>
<a class="header" href="print.html#ros-1" id="ros-1"><h1>Ros</h1></a>
<p>ROS starts with the ROS Master. The Master allows all other ROS pieces of software (Nodes) to find and talk to each other. That way, we do not have to ever specifically state “Send this sensor data to that computer at 127.0.0.1. We can simply tell Node 1 to send messages to Node 2. But... how do Nodes do this? By publishing and subscribing to <code>TOPICS</code>.</p>
<p>The ROS Master provides name registration and lookup to the rest of the Computation Graph.</p>
<p><img src="http://www.clearpathrobotics.com/assets/guides/ros/_images/ros101one.png" alt="alt text" title="ROS GRAPH" /></p>
<blockquote>
<p>This content is based on <a href="https://www.clearpathrobotics.com/">Clearpath Robotics</a> documentation. For further information refer to their <a href="http://www.clearpathrobotics.com/assets/guides/ros/Intro%20to%20the%20Robot%20Operating%20System.html">ROS Tutorials</a>.</p>
</blockquote>
<a class="header" href="print.html#nodes" id="nodes"><h1>Nodes</h1></a>
<p>Nodes are executables that can communicate with other processes using topics,
services, or the Parameter Server. Using nodes in ROS provides us with fault
tolerance and separates the code and functionalities, making the system simpler.</p>
<p>A node must have a unique name in the system. This name is used to permit the
node to communicate with another node using its name without ambiguity.</p>
<p>ROS has tools to handle nodes and give us information about it, such as <code>rosnode</code>.</p>
<p>The rosnode tool is a command-line tool used to display information about nodes,
such as listing the currently running nodes. The supported commands are as follows:</p>
<ul>
<li><code>rosnode info NODE</code>: This prints information about a node</li>
<li><code>rosnode kill NODE</code>: This kills a running node or sends a given signal</li>
<li><code>rosnode list</code>: This lists the active nodes</li>
<li><code>rosnode machine hostname</code>: This lists the nodes running on a particular machine or lists machines</li>
<li><code>rosnode ping NODE</code>: This tests the connectivity to the node.</li>
<li><code>rosnode cleanup</code>: This purges the registration information from unreachable nodes</li>
</ul>
<a class="header" href="print.html#topics" id="topics"><h1>Topics</h1></a>
<p>Topics are buses used by nodes to transmit data. Topics can be transmitted without a
direct connection between nodes, which means that the production and consumption
of data are decoupled. A topic can have various subscribers and can also have
various publishers, but you can take care about publishing the same topic with
different nodes because it can create conflicts.</p>
<p>Each topic is strongly typed by the ROS message type used to publish it, and nodes
can only receive messages from a matching type. A node can subscribe to a topic
only if it has the same message type.</p>
<p>ROS has a tool to work with topics called <code>rostopic</code>. It is a command-line tool
that gives us information about the topic or publishes data directly on the network.
This tool has the following parameters:</p>
<ul>
<li><code>rostopic list</code>: This prints information about active topics.</li>
<li><code>rostopic pub /topic type args</code>: This publishes data to the topic.
It allows us to create and publish data in whatever topic we want,
directly from the command line.</li>
<li><code>rostopic echo /topic</code>: This prints messages to the screen.</li>
<li><code>rostopic find message_type</code>: This finds topics by their type.</li>
<li><code>rostopic info /topic</code>: This prints information about the active topic,</li>
<li><code>rostopic hz /topic</code>: This displays the publishing rate of the topic.
topics published, ones it is subscribed to, and services.</li>
<li><code>rostopic type /topic</code>: This prints the topic type, that is, the type of
message it publishes.</li>
<li><code>rostopic bw /topic</code>: This displays the bandwidth used by the topic.</li>
</ul>
<a class="header" href="print.html#messages" id="messages"><h1>Messages</h1></a>
<p>A node sends information to another node using messages that are published
by topics. The message has a simple structure that uses standard types or types
developed by the user.</p>
<p>Message types use the following standard ROS naming convention; the name of the
package, then /, and then the name of the .msg file. For example, <strong>std_msgs/msg/String.msg</strong> has the <strong>std_msgs/String</strong> message type.</p>
<p>ROS has the <code>rosmsg</code> command-line tool to get information about messages. The
accepted parameters are as follows:</p>
<ul>
<li><code>rosmsg show</code>: This displays the fields of a message</li>
<li><code>rosmsg list</code>: This lists all messages</li>
<li><code>rosmsg package</code>: This lists all of the messages in a package</li>
<li><code>rosmsg packages</code>: This lists all of the packages that have the message</li>
<li><code>rosmsg users</code>: This searches for code files that use the message type</li>
</ul>
<a class="header" href="print.html#workspaces" id="workspaces"><h1>Workspaces</h1></a>
<p>The first thing you will want to do before you write code is create an environnement for your project. This environnement is called <em>Workspace</em>. The Workspace is the root folder containing subfolders and files essential to run your project.
These files will be generated using the <strong>catkin_init_workspace</strong> command.</p>
<p>Let's get into it!
<br><br></p>
<ul>
<li>Choose a directory for your workspace, let's use 'catkin_ws'</li>
</ul>
<pre><code>mkdir -p ~/catkin_ws/src
cd ~/catkin_ws/src
catkin_init_workspace
</code></pre>
<p>This will create a <strong>CMakeLists.txt</strong> file in your <strong>/src</strong> folder.
<br><br></p>
<ul>
<li>Then we will make the project</li>
</ul>
<pre><code>cd ~/catkin_ws
catkin_make
</code></pre>
<p>This will create two subfolders, <strong>build</strong> and <strong>devel</strong>. The <strong>build</strong> folder is none of our interest in most of the part. The <strong>devel</strong> folder contains a number of files and directories, the most interesting of which are the setup files. Running these configures your system to use this workspace, and the code that’s (going to be) contained inside it.
<br><br></p>
<ul>
<li>Configure your machine to use this Workspace</li>
</ul>
<pre><code>source devel/setup.bash
</code></pre>
<p>That's it, you've got your workspace up and running!</p>
<a class="header" href="print.html#ros-packages" id="ros-packages"><h1>ROS Packages</h1></a>
<p>ROS software is organized into packages, each of which contains some combination of code, data, and documentation. Usually there is a package for each 'function' of your robot. For example, you can have a package for navigation or for sensor capturing.
Thanks to the contributing community, there are many pre built packages available to download for free.</p>
<p>Let's create our first package!</p>
<ul>
<li>Creating a packages</li>
</ul>
<pre><code>cd ~/catkin_ws/src
catkin_create_pkg my_awesome_code rospy
</code></pre>
<p>This creates a new package named <strong>my_awesome_code</strong>. Inside that folder we'll find a <strong>/src</strong> directory where we will put our python code.</p>
<a class="header" href="print.html#complementary-info" id="complementary-info"><h2>Complementary info</h2></a>
<a class="header" href="print.html#roscore" id="roscore"><h3>roscore</h3></a>
<p>The <code>roscore</code> command is a service that provides connection information to nodes so that they can transmit messages to one another. <strong>It is necessary to run this command before launching any package</strong>.</p>
<a class="header" href="print.html#rosrun" id="rosrun"><h3>rosrun</h3></a>
<p>To run a package, we use the <code>rosrun</code> command executed like this:</p>
<pre><code>rosrun PACKAGE EXECUTABLE [ARGS]
</code></pre>
<p><strong>PACKAGE</strong> is the name of the created package, for example <strong>my_awesome_code</strong>, and <strong>EXECUTABLE</strong> is the name of the python file containing the code. <strong>Attention!</strong> The python file needs to be executable, juste use <code>sudo chmod +x file.py</code></p>
<a class="header" href="print.html#publisher-node" id="publisher-node"><h1>Publisher Node</h1></a>
<p>As shortly mentioned in the basic concept part, ROS allows interaction pulisher nodes and subscriber nodes.
In this chapter we'll create our first publisher node, which will send a basic message.</p>
<p>Make sure your current path is the previously created package.</p>
<a class="header" href="print.html#create-a-python-file" id="create-a-python-file"><h3>Create a python file</h3></a>
<pre><code>touch talker.py
</code></pre>
<a class="header" href="print.html#make-it-executable" id="make-it-executable"><h3>Make it executable</h3></a>
<pre><code>sudo chmod +x talker.py
</code></pre>
<a class="header" href="print.html#add-the-following-code" id="add-the-following-code"><h3>Add the following code</h3></a>
<pre><code>import rospy
from std_msgs.msg import String

def talker():
    pub = rospy.Publisher('chatter', String, queue_size=10)
    rospy.init_node('talker', anonymous=True)
    rate = rospy.Rate(10) # 10hz
    while not rospy.is_shutdown():
        hello_str = &quot;hello world %s&quot; % rospy.get_time()
        rospy.loginfo(hello_str)
        pub.publish(hello_str)
        rate.sleep()

if __name__ == '__main__':
    try:
        talker()
    except rospy.ROSInterruptException:
        pass
</code></pre>
<p>First we create the publisher node with reference 'chatter' and initialize it.</p>
<p>Then we go through a loop and create a 'hello world' string that we will publish on this 'talker' node.</p>
<p><code>rospy.loginfo()</code> is used to debug info to the user but doesn't interact with the node itself.</p>
<p>We could now run <code>roscore</code> and <code>rosrun my_awesome_code talker</code> in the console and see the debugger info but we don't have anybody subscribed(listening) to that <code>talker</code> node yet.</p>
<a class="header" href="print.html#subscriber-node" id="subscriber-node"><h1>Subscriber Node</h1></a>
<p>In this chapter we'll create our first listener node, which will retrieve info from another publishing node.</p>
<p>Make sure your current path is the previously created package.</p>
<a class="header" href="print.html#create-a-python-file-1" id="create-a-python-file-1"><h3>Create a python file</h3></a>
<pre><code>touch listener.py
</code></pre>
<a class="header" href="print.html#make-it-executable-1" id="make-it-executable-1"><h3>Make it executable</h3></a>
<pre><code>sudo chmod +x listener.py
</code></pre>
<a class="header" href="print.html#add-the-following-code-1" id="add-the-following-code-1"><h3>Add the following code</h3></a>
<pre><code>import rospy
from std_msgs.msg import String

def callback(data):
    rospy.loginfo(rospy.get_caller_id() + 'I heard %s', data.data)

def listener():

    # In ROS, nodes are uniquely named. If two nodes with the same
    # name are launched, the previous one is kicked off. The
    # anonymous=True flag means that rospy will choose a unique
    # name for our 'listener' node so that multiple listeners can
    # run simultaneously.
    rospy.init_node('listener', anonymous=True)

    rospy.Subscriber('chatter', String, callback)

    # spin() simply keeps python from exiting until this node is stopped
    rospy.spin()

if __name__ == '__main__':
    listener()
</code></pre>
<p>First we initialize the <code>listener</code> node and then tell it to subscribe to the previously created <code>chatter</code> node.
Here we also need to mention what to do with any incoming data from the <code>chatter</code> node. In this case, this function is called <code>callback</code>.</p>
<p>Now anytime we get incoming data from the subscribed <code>chatter</code> node, the <code>callback</code> function will log the data.</p>
<p>Note here that we specify the type of the incoming data (String).</p>
<a class="header" href="print.html#test-if-everything-is-working" id="test-if-everything-is-working"><h3>Test if everything is working</h3></a>
<pre><code class="language-roscore">rosrun my_awesome_code talker
rosrun my_awesome_code listener

</code></pre>
<p>You should now be able to see the following output:</p>
<pre><code>[INFO] [WallTime: 1439848277.141546] /listener_14364_1439848276913 \ I heard hello world 1439848277.14
[INFO] [WallTime: 1439848277.241519] /listener_14364_1439848276913 \ I heard hello world 1439848277.24
[INFO] [WallTime: 1439848277.341668] /listener_14364_1439848276913 \ I heard hello world 1439848277.34
[INFO] [WallTime: 1439848277.441579] /listener_14364_1439848276913 \ I heard hello world 1439848277.44
</code></pre>
<a class="header" href="print.html#launch-files" id="launch-files"><h1>Launch files</h1></a>
<p>Launch files are very common in ROS to both users and developers. They provide a convenient way to start up multiple nodes and a master, as well as other initialization requirements such as setting parameters.</p>
<a class="header" href="print.html#roslaunch" id="roslaunch"><h2>Roslaunch</h2></a>
<p><code>roslaunch</code> is used to open launch files. This can be done by either specifying the package the launch files are contained in followed by the name of the launch file, or by specifying the file path to the launch file.</p>
<pre><code class="language-bash">roslaunch package_name launch_file arg1:=value arg2:=value
</code></pre>
<blockquote>
<p>roslaunch will also start <code>roscore</code> if no master has been set. Pushing <code>Ctrl-C</code> in a terminal with a launch file running will close all nodes that were started with that launch files.</p>
</blockquote>
<a class="header" href="print.html#writing-a-launch-files" id="writing-a-launch-files"><h2>Writing a .launch files</h2></a>
<p>Launch files are of the format .launch and use a specific XML format. They can be placed anywhere within a package directory, but it is common to make a directory named <strong>Launch</strong> inside the workspace directory to organize all your launch files. The contents of a launch file must be contained between a pair of launch tags</p>
<pre><code class="language-xml">&lt;launch&gt;&lt;!-- Content here --&gt;&lt;/launch&gt;
</code></pre>
<p>To actually start a node, the <code>&lt;node&gt;</code> tags are used, the <strong>pkg</strong>, <strong>type</strong> and <strong>name</strong> argument are required.</p>
<pre><code class="language-xml">&lt;node pkg=&quot;...&quot; type=&quot;...&quot; name=&quot;...&quot; respawn=true/&gt;
</code></pre>
<ul>
<li>
<p><code>pkg, type and name</code>: The argument <strong>pkg</strong> points to the package associated with the node that is to be launched, while <strong>type</strong> refers to the name of the node executable file.</p>
</li>
<li>
<p><code>respawn or required</code>: However optional, it’s common to either have a respawn argument or a required argument, but not both. If <strong>respawn=true</strong>, then this particular node will be restarted if for some reason it closed. <strong>required=true</strong> will do the opposite, that is, it will shut down all the nodes associated with a launch file if this particular node comes down. There are other optional argument available on the ROS wiki.</p>
</li>
<li>
<p><code>arg</code>: Sometimes it is necessary to use a local variable in launch files. This can be done using</p>
</li>
</ul>
<pre><code class="language-xml">&lt;arg name=&quot;...&quot; value=&quot;...&quot;&gt;
</code></pre>
<a class="header" href="print.html#parameter-server" id="parameter-server"><h1>Parameter server</h1></a>
<p>Configuration information in ROS is usually saved to the Parameter server. The Parameter sever is a collection of values that can be accessed upon request through the command prompt, nodes or launch files. Parameters are intended to be fairly static, globally available values such as integers, floats, strings or bool values.</p>
<a class="header" href="print.html#parameters" id="parameters"><h2>Parameters</h2></a>
<p>Parameters are named using the normal ROS naming convention. This means that ROS parameters have a hierarchy that matches the namespaces used for topics and nodes. This hierarchy is meant to protect parameter names from colliding.</p>
<pre><code>/motors/front/left: 5.0
/motors/front/right: 4.0
/motors/rear/left: 4.0
/motors/rear/right: 5.0
</code></pre>
<p>The parameter <code>/motors/front/left</code> has the value <code>5.0</code>. You can also get the value for <code>/motors/front</code>, which is the dictionary</p>
<pre><code>left: 5.0
right: 4.0
</code></pre>
<p>And you can also get the value for <code>/motors</code>, which has a dictionary of dictionaries representation of the parameter tree:</p>
<pre><code>front: { left: 5.0, right: 4.0 }
rear: { left: 4.0, right: 5.0 }
</code></pre>
<a class="header" href="print.html#parameters-from-the-terminal" id="parameters-from-the-terminal"><h2>Parameters from the terminal</h2></a>
<p>ROS has a tool called <code>rosparam</code> to manage Parameter Server. The accepted parameters are as follows:</p>
<ul>
<li><code>rosparam set parameter value</code>: This sets the parameter</li>
<li><code>rosparam get parameter</code>: This gets the parameter</li>
<li><code>rosparam load file</code>: This loads parameters from the file</li>
<li><code>rosparam dump file</code>: This dumps parameters to the file</li>
<li><code>rosparam delete parameter</code>: This deletes the parameter</li>
<li><code>rosparam list</code>: This lists the parameter names</li>
</ul>
<p>For example, we can see the parameters in the server that are used by all nodes:</p>
<pre><code class="language-bash">rosparam list
</code></pre>
<p>We obtain the following output for the above example:</p>
<pre><code class="language-bash">/motors/front/left
/motors/front/right
/motors/rear/left
/motors/rear/right
</code></pre>
<p>If you want to read a value, you will use the <code>get</code> parameter:</p>
<pre><code>rosparam get /motors/front/left
</code></pre>
<p>To set a new value, you will use the <code>set</code> parameter:</p>
<pre><code>rosparam set /motors/front/left 6.0
</code></pre>
<a class="header" href="print.html#accessing-parameters-from-nodes" id="accessing-parameters-from-nodes"><h2>Accessing parameters from nodes</h2></a>
<p>It is often the case that your nodes will have to access the parameter server during start up to retrieve configuration information, or set a parameter value. This can be done quite easily in Python, to set a parameter use:</p>
<pre><code class="language-python">rospy.param_set(/motors/front/left, 6.0)
rospy.param_get(/motors/front/left)
</code></pre>
<a class="header" href="print.html#accessing-parameters-from-launchfiles" id="accessing-parameters-from-launchfiles"><h2>Accessing parameters from launchfiles</h2></a>
<p>The final source where you may need to access the parameter server is from a launch file. Setting a parameter value during a launch file is common practice to conveniently initialize parameters on start up. This can be done in your launch file using</p>
<pre><code class="language-yaml">&lt;param name=&quot;/motors/front/left&quot; value=&quot;6.0&quot;/&gt;
</code></pre>
<a class="header" href="print.html#ros-and-arduino" id="ros-and-arduino"><h1>ROS and Arduino</h1></a>
<a class="header" href="print.html#publisher" id="publisher"><h1>Publisher</h1></a>
<p>To use ROS in an Arduino script you first have to include some libraries :</p>
<pre><code>#include &lt;ros.h&gt;
#include &lt;std_msgs/Type.h&gt;
</code></pre>
<p>You have to replace «Type» with the type of the std message you are using. Here are the different types of std_msgs : <a href="http://wiki.ros.org/std_msgs">http://wiki.ros.org/std_msgs</a>.</p>
<p>You can also use different kind of messages. For instance the ultrasound sensors use :</p>
<pre><code>#include &lt;sensor_msgs/Range.h&gt;
</code></pre>
<p>Then you have to start a ROS node (takes care of serial port communications, allows to create publishers and subscribers) with this line :</p>
<pre><code>ros::NodeHandle nh;
</code></pre>
<p>You can now create a message object that you will later fill with data and this is the message you will finally publish :</p>
<pre><code>std_msgs::String msg;
</code></pre>
<p>where msg is the name of the object. And of course you can choose the type of the message depending on the type of the transferred message.</p>
<p>Then you have to choose if you want to create a publisher, a subscriber or even both.</p>
<p>To create a publisher :</p>
<pre><code>ros::Publisher chatter(&quot;chatter&quot;, &amp;msg);
</code></pre>
<p>This tells that we are going to be publishing a message of the type of the msg variable (with std_msgs::String type) on the topic «chatter». This lets the master tell any nodes listening on «chatter» that we are going to publish data on that topic.</p>
<p>You can now add lines in the void setup() of the Arduino script. You first initialize the node :</p>
<pre><code>nh.initNode()
</code></pre>
<p>Next, the following call connects to the master to publicize that the node will be publishing messages on the given topic :</p>
<pre><code>nh.advertise(chatter);
</code></pre>
<p>So finally this is what the void setup() in your Arduino code should look like :</p>
<pre><code>void setup()
{
   nh.initNode();
   nh.advertise(chatter);
}
</code></pre>
<p>To fill the message object with the data you just have to do this :</p>
<pre><code>msg.data = hello;
</code></pre>
<p>where hello is the data you put in your message and hello must have the same type as the msg variable.</p>
<p>You can then publish you message on the topic. To do so you can either publish it once or continually in the void loop() of your Arduino code like this :</p>
<pre><code>
void loop()
{
   chatter.publish( &amp;str_msg );
}
</code></pre>
<p>Finally you have to add a last line of code in the loop that will call all the callbacks waiting to be called at that point in time :</p>
<pre><code>nh.spinOnce();
</code></pre>
<p>Now that you know how each part of the code works you can test a «Hello World» example available on the wiki.ros.org website <a href="http://wiki.ros.org/rosserial_arduino/Tutorials/Hello%20World">http://wiki.ros.org/rosserial_arduino/Tutorials/Hello%20World</a> :</p>
<pre><code>/*
 * rosserial Publisher Example
 * Prints &quot;hello world!&quot;
 */
// Use the following line if you have a Leonardo or MKR1000 
//#define USE_USBCON 

#include &lt;ros.h&gt;
#include &lt;std_msgs/String.h&gt;

ros::NodeHandle nh;

std_msgs::String str_msg;
ros::Publisher chatter(&quot;chatter&quot;, &amp;str_msg);

char hello[13] = &quot;hello world!&quot;;

void setup()
{
  nh.initNode();
  nh.advertise(chatter);
}

void loop()
{
  str_msg.data = hello;
  chatter.publish( &amp;str_msg );
  nh.spinOnce();
  delay(1000);
}
</code></pre>
<p>You have to upload this code on the Arduino board before connecting it to the Raspberry and before starting the test on ROS.</p>
<a class="header" href="print.html#test-on-a-raspberry" id="test-on-a-raspberry"><h1>Test on a Raspberry</h1></a>
<p>To test it you first have to connect the Arduino board to the Raspberry. Then you launch the terminal and execute the following commands :</p>
<p>on a first window you type :</p>
<pre><code>roscore
</code></pre>
<p>on another window :</p>
<pre><code>rosrun rosserial_python serial_node.py /dev/ttyUSB0 
</code></pre>
<p>/dev/ttyUSB0 is the usb port the Arduino is connected to so you’ll have to change the «USB0». You can find the name of the port tty* in the Arduino IDE or you can find it in the terminal by typing :</p>
<pre><code>ls /dev/tty*
</code></pre>
<p>when you plug the Arduino in the Raspberry port, you can execute this previous command to see which port has been added and thus know which one is the Arduino board.</p>
<p>Finally you can see what the Arduino is publishing on a specific topic by typing on another terminal window :</p>
<pre><code>rostopic echo /topic_name
</code></pre>
<p>where you have to replace topic_name by the topic your Arduino is publishing on. In the example above, the «hello world!» is published on the topic «chatter». So you can type :</p>
<pre><code>rostopic echo /chatter
</code></pre>
<a class="header" href="print.html#subscriber" id="subscriber"><h1>Subscriber</h1></a>
<p>To try this tutorial on you Arduino board you have to connect a Led. The pin used here is the 13 but of course you can change it in the code if you want to use another one.</p>
<p>As in the Arduino Publisher Tutorial you first have to include the libraries. One of them depends on the message you are transferring with ROS. In the following example we will choose an empty message. This means that the message doesn’t contain anything. So when the subscriber receives the message, it doesn’t react depending on its content but it only reacts because a message has been sent. As the type of the std_msg is «Empty», you have to include the following lines at the beginning of your Arduino code :</p>
<pre><code>#include &lt;ros.h&gt;
#include &lt;std_msgs/Empty.h&gt;
</code></pre>
<p>Here again, like the Arduino Publisher Tutorial code, you have to start a ROS node with this line :</p>
<pre><code>ros::NodeHandle nh;
</code></pre>
<p>Then you initiate the callback function where you have to specify the name of the callback (messageCb), the type of the message (std_msgs::Empty) and the name of the message (toggle_msg which contains the transferred message). The callback is the function called each time you receive a message. If toggle_msg had a content you could use it in the callback but it is not the case here as the message is of type «Empty».</p>
<pre><code>void messageCb( const std_msgs::Empty&amp; toggle_msg){
  digitalWrite(13, HIGH-digitalRead(13));   // blink the led
}
</code></pre>
<p>The following line of code is used to instantiate the subscriber. To do so you have to specify two arguments : the topic name (we chose in this example : «toggle_led») and the callback function we defined previously (messageCb).</p>
<pre><code>ros::Subscriber&lt;std_msgs::Empty&gt; sub(&quot;toggle_led&quot;, &amp;messageCb );
</code></pre>
<p>As this is a blink led example, in the setup part of your Arduino code you first have to use the number 13 pin as an output.</p>
<pre><code>pinMode(13, OUTPUT);
</code></pre>
<p>Then for the ROS part of the setup you have to first initialize the node :</p>
<pre><code>nh.initNode();
</code></pre>
<p>And subscribe to the node you want to :</p>
<pre><code>nh.subscribe(sub);
</code></pre>
<p>So finally this is what the void setup() in your Arduino code should look like :</p>
<pre><code>void setup()
{
  pinMode(13, OUTPUT);
  nh.initNode();
  nh.subscribe(sub);
}
</code></pre>
<p>Finally you just have to add in the void loop of your Arduino code the following lines where the spinOnce passes arguments to the callback :</p>
<pre><code>void loop()
{
  nh.spinOnce();
  delay(1);
}
</code></pre>
<p>Now that you know how each part of the code works you can test the blink led example available on the wiki.ros.org website <a href="http://wiki.ros.org/rosserial_arduino/Tutorials/Blink">http://wiki.ros.org/rosserial_arduino/Tutorials/Blink</a> :</p>
<pre><code>/*
 * rosserial Subscriber Example
 * Blinks an LED on callback
 */
#include &lt;ros.h&gt;
#include &lt;std_msgs/Empty.h&gt;

ros::NodeHandle nh;

void messageCb( const std_msgs::Empty&amp; toggle_msg){
  digitalWrite(13, HIGH-digitalRead(13));   // blink the led
}

ros::Subscriber&lt;std_msgs::Empty&gt; sub(&quot;toggle_led&quot;, &amp;messageCb );

void setup()
{
  pinMode(13, OUTPUT);
  nh.initNode();
  nh.subscribe(sub);
}

void loop()
{
  nh.spinOnce();
  delay(1);
}
</code></pre>
<p>You have to upload this code on the Arduino board before connecting it to the Raspberry and before starting the test on ROS.</p>
<a class="header" href="print.html#test-on-a-raspberry-1" id="test-on-a-raspberry-1"><h1>Test on a Raspberry</h1></a>
<p>To test it you first have to connect the Arduino board to the Raspberry. Then you launch the terminal and execute the following commands :</p>
<p>on a first window you type :</p>
<pre><code>roscore
</code></pre>
<p>on another window :</p>
<pre><code>rosrun rosserial_python serial_node.py /dev/ttyUSB0 
</code></pre>
<p>/dev/ttyUSB0 is the usb port the Arduino is connected to so you’ll have to change the «USB0». You can find the name of the port tty* in the Arduino IDE or you can find it in the terminal by typing :</p>
<pre><code>ls /dev/tty*
</code></pre>
<p>when you plug the Arduino in the Raspberry usb port, you can execute this previous command to see which port has been added and thus know which one is the Arduino board.</p>
<p>Finally, in order to send a single message to the Arduino, you can publish on a specific topic by typing on another terminal window :</p>
<pre><code>rostopic pub toggle_led std_msgs/Empty --once
</code></pre>
<p>where toggle_led is the topic you are publishing on, std_msgs/Empty is the type of the message and we use «—once» to publish this message only once.</p>
<a class="header" href="print.html#useful-packages" id="useful-packages"><h1>Useful packages</h1></a>
<a class="header" href="print.html#map-server" id="map-server"><h1>Map Server</h1></a>
<a class="header" href="print.html#navigation-stack" id="navigation-stack"><h1>Navigation stack</h1></a>
<a class="header" href="print.html#color-detection" id="color-detection"><h1>Color detection</h1></a>
<blockquote>
<p>The objective of this module is to detect a color combination and send it to the “Minus” robot module whose function is to build a tower made of cubes.</p>
</blockquote>
<a class="header" href="print.html#getting-started" id="getting-started"><h2>Getting started</h2></a>
<a class="header" href="print.html#image-treatment-module" id="image-treatment-module"><h3>Image treatment module</h3></a>
<a class="header" href="print.html#aim" id="aim"><h4>Aim</h4></a>
<p>First and foremost, we must connect to GoPro wifi to take a picture of the color combination. Here, we have chosen a GoPro as a camera because it has an acceptable quality (780 pixel-HD) and it has also a Wi-Fi module for the remote control.</p>
<p>Once the photo has been taken, the camera automatically switches off and we connect to the robot by wifi (a Raspberry connected with the same Wi-Fi for future image treatment).</p>
<p>During this treatment, we use the OpenCV free graphics library.</p>
<p>We have drawn three frames on the picture (one for each cube to detect) to delimit the test portion.</p>
<p>The board analyzes all pixels within each frame:</p>
<ol>
<li>It looks whether the color detected is in the range color defined for every color (each color range is defined with one high and one low BGR value)</li>
<li>After that, it returns a value: more the value is great, more the color lies within the range. The program adds up the values and the final value thus obtained determines the color within the range of colors determined initially.</li>
</ol>
<p>However, we have implemented in our program the different possible combinations to save time. Indeed, we only required two colors to deduce the final combination.</p>
<p>As a matter of conclusion, we send combination to the robot by ROS.</p>
<p><img src="img/software/image-processing/image1.png" alt="z" /></p>
<a class="header" href="print.html#bill-of-materials" id="bill-of-materials"><h4>Bill of materials:</h4></a>
<ul>
<li>One Raspberry Pi zero W</li>
<li>One Wi-Fi GoPro (Hero+)</li>
<li>One 5V battery</li>
<li>Etcher (https://etcher.io/) to install an OS on the Raspberry</li>
</ul>
<a class="header" href="print.html#connections" id="connections"><h4>Connections</h4></a>
<ul>
<li>No pins required</li>
</ul>
<a class="header" href="print.html#setup" id="setup"><h4>Setup</h4></a>
<ul>
<li>Download last version Ubuntu mate (16.04) or an another distribution for the raspberry (see <a href="ros/install.md">install</a>)</li>
<li>Active WiFi and open terminal (<strong><em>alt+ctrl+t</em></strong>):
<ol>
<li>
<p>Install ROS (see <a href="ros/install.md">install</a>)</p>
</li>
<li>
<p>Import this repo from github</p>
</li>
<li>
<p>Go to &quot;codes&quot; folder:</p>
<pre><code>cd src/codes/software/image-processing/tests
</code></pre>
</li>
<li>
<p>Connect the GoPro or your webcam to the Raspberry</p>
</li>
<li>
<p>For testing the camera, go to &quot;test camera&quot; folder :</p>
<pre><code>cd test_camera
</code></pre>
<ul>
<li>For GoPro:</li>
</ul>
<pre><code>python3 go_pro_test.py
</code></pre>
<p><strong><em>Don't forget to connect the GoPro WiFi to the raspberry Pi !</em></strong></p>
<ul>
<li>For the webcam:</li>
</ul>
<pre><code>python webcam_test.py
</code></pre>
</li>
</ol>
</li>
</ul>
<p><strong>Scripts</strong></p>
<ul>
<li>Go to color_detection folder :</li>
</ul>
<pre><code>cd ../test_color_detection
</code></pre>
<ul>
<li>Open GP_combination.sh :</li>
</ul>
<pre><code>nano GP_combination.sh 
</code></pre>
<ul>
<li>Change <strong><em>line3</em></strong> with the name of your GoPro WiFi :</li>
</ul>
<pre><code>nmcli c up &quot;your GoPro wifi&quot;
</code></pre>
<ul>
<li>Change <strong><em>line6</em></strong> with the name of robot WiFi</li>
</ul>
<pre><code>nmcli c up &quot;your wifi robot&quot;
</code></pre>
<p>save it (<strong><em>ctrl+x</em></strong>)</p>
<ul>
<li>Run this script on the terminal :</li>
</ul>
<pre><code>bash GP_combination.sh 
</code></pre>
<p>If you use the webcam :</p>
<pre><code>bash WB_combination.sh 
</code></pre>
<p>You'll see 3 colors frames on the picture and the final combination color on the terminal)</p>
<a class="header" href="print.html#adjust-position-of-a-frame" id="adjust-position-of-a-frame"><h5>Adjust position of a frame</h5></a>
<ul>
<li>Maintain your cursor where you want to place a side of the frame.</li>
<li>Take note of the position.</li>
<li>Open a new tab (<strong><em>ctrl+shift+t</em></strong>)</li>
<li>Change the position in the code :</li>
</ul>
<pre><code>nano color_detection.py
</code></pre>
<p><img src="img/software/image-processing/image2.png" alt="before" />
Note : xmin is the left side of the square, xmax is the right side of the square, ymin is the top side of the square and ymax is the bottom side of the square.</p>
<ul>
<li>Restart for another side of the frame and save the file (<strong><em>ctrl+x</em></strong>)</li>
</ul>
<p><img src="img/software/image-processing/image3.png" alt="after" /></p>
<a class="header" href="print.html#adjust-range-color" id="adjust-range-color"><h5>Adjust range color</h5></a>
<ul>
<li>Maintain your cursor in the center of the cube</li>
<li>Take note of the RGB color</li>
<li>Open a new tab (<strong><em>ctrl+shift+t</em></strong>)</li>
<li>Change the color range in the code (color_detection.py) and save the file (<strong><em>ctrl+x</em></strong>)
<img src="img/software/image-processing/image4.png" alt="z" /></li>
</ul>
<a class="header" href="print.html#ros-2" id="ros-2"><h5>ROS</h5></a>
<p>You use <strong><em>ROS</em></strong> to send the color combination to another robot module :</p>
<ul>
<li>Open terminal and launch ROS :</li>
</ul>
<pre><code>. ~/eurobot_ws/devel/setup.bash
roslaunch image-processing test.launch 
</code></pre>
<ul>
<li>Open a new tab (<strong><em>ctrl+shift+t</em></strong>) and display messages published to a topic :</li>
</ul>
<pre><code>rostopic echo /color_seq 
</code></pre>
<p><strong><em>Don't forget to change frames positions and color ranges !</em></strong></p>
<a class="header" href="print.html#flashlight-module" id="flashlight-module"><h3>Flashlight module</h3></a>
<a class="header" href="print.html#aim-1" id="aim-1"><h4>Aim</h4></a>
<p>We added a LED flashlight above the camera because light is an important factor and can bias our previous calculations. Therefore, the constant level of light thus created enables us to maintain our settings. This flashlight is turned off immediately after the camera has taken the photo, so as not to disrupt other teams or distract the audience.</p>
<a class="header" href="print.html#bill-of-materials-1" id="bill-of-materials-1"><h4>Bill of materials:</h4></a>
<ul>
<li>One Raspberry Pi zero W</li>
<li>One LED flashlight</li>
<li>One 5V battery</li>
</ul>
<a class="header" href="print.html#connections-1" id="connections-1"><h4>Connections</h4></a>
<p>We use pin 4 of the raspberry Pi zero to power the gate pin of IRF520 mosfet in order to control the light. The board is powered with a 5V power supply from the battery (pin 2 = 5V and pin 6= GND).</p>
<a class="header" href="print.html#setup-1" id="setup-1"><h4>Setup</h4></a>
<ul>
<li>for testing the flashlight, run :</li>
</ul>
<pre><code>python flashlight.py
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script type="text/javascript">
            document.addEventListener('DOMContentLoaded', function() {
                window.print();
            })
        </script>
        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

    </body>
</html>
